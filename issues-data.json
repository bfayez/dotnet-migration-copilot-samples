[
  {
    "title": "Application Inventory and Dependency Analysis",
    "body": "# Task: Application Inventory and Dependency Analysis\n\n## Phase\nPhase 0: Assessment and Planning (Week 1, Day 1-2)\n\n## Description\nComplete a thorough inventory of the ContosoUniversity application and analyze all dependencies to understand the scope of the migration.\n\n## Objectives\n- Document all application components and their interactions\n- Identify all external dependencies (NuGet packages, system dependencies)\n- Analyze Windows-specific dependencies that need replacement\n- Create a comprehensive dependency map\n- Identify potential migration blockers\n\n## Prerequisites\n- Access to the ContosoUniversity source code\n- Access to the current hosting environment\n- Documentation review (README files)\n\n## Dependencies\nNone (This is the starting task)\n\n## Tasks\n1. **Application Components Inventory:**\n   - List all controllers and their responsibilities\n   - Document all models and their relationships\n   - Catalog all views and partial views\n   - Identify all services and business logic components\n   - Document data access patterns\n\n2. **Dependency Analysis:**\n   - Extract all NuGet package dependencies from packages.config\n   - Identify .NET Framework-specific dependencies\n   - Document Windows-specific dependencies (MSMQ, IIS features)\n   - Analyze third-party library compatibility with .NET 9\n   - Check for deprecated APIs and breaking changes\n\n3. **Infrastructure Dependencies:**\n   - Document current hosting requirements (IIS, Windows Server)\n   - Identify authentication mechanisms (Windows Authentication)\n   - Document file system dependencies (upload directories)\n   - Analyze message queue implementation (MSMQ)\n   - Document database schema and migrations\n\n4. **Create Dependency Map:**\n   - Create visual diagram showing component relationships\n   - Document data flow between components\n   - Identify critical paths and workflows\n   - Document integration points\n\n## Deliverables\n- [ ] Application components inventory document\n- [ ] Complete dependency list (NuGet, system, external)\n- [ ] Windows-specific dependencies report\n- [ ] Compatibility assessment for .NET 9\n- [ ] Dependency diagram/map\n- [ ] Risk assessment for identified dependencies\n\n## Acceptance Criteria\n- All controllers, models, views, and services documented\n- All NuGet packages cataloged with versions\n- All Windows-specific dependencies identified\n- Compatibility issues documented with mitigation strategies\n- Dependency map created and reviewed\n- No missing components or dependencies\n\n## Estimated Effort\n2 days\n\n## Notes\n- Use tools like NDepend or Visual Studio dependency graphs if available\n- Document both direct and transitive dependencies\n- Pay special attention to System.Web, System.Messaging, and other framework-specific namespaces\n- This inventory will inform all subsequent migration tasks\n",
    "labels": [
      "phase-0",
      "setup",
      "critical",
      "1-week"
    ],
    "file_path": "tasks/phase-0-assessment-planning/01-application-inventory.md",
    "phase": "phase-0-assessment-planning",
    "task_number": 1
  },
  {
    "title": "Set Up Azure Subscription and Resource Groups",
    "body": "# Task: Set Up Azure Subscription and Resource Groups\n\n## Phase\nPhase 0: Assessment and Planning (Week 1, Day 3-4)\n\n## Description\nSet up the Azure subscription, resource groups, and initial configuration for the migration project.\n\n## Objectives\n- Create or configure Azure subscription\n- Establish resource group structure\n- Set up naming conventions and tagging strategy\n- Configure access control and permissions\n- Establish cost management and monitoring\n\n## Prerequisites\n- Azure account with appropriate permissions\n- Approved budget for Azure resources\n- Project team identified\n\n## Dependencies\n- Task 01: Application Inventory and Dependency Analysis (to understand resource requirements)\n\n## Tasks\n1. **Azure Subscription Setup:**\n   - Create or configure Azure subscription\n   - Set up billing alerts and budget limits\n   - Configure cost management policies\n   - Document subscription details\n\n2. **Resource Group Structure:**\n   - Create resource group for Development environment\n   - Create resource group for Production environment (optional at this stage)\n   - Apply naming conventions (e.g., rg-contoso-university-dev, rg-contoso-university-prod)\n   - Set up resource group tags (Environment, Project, Owner, CostCenter)\n\n3. **Access Control:**\n   - Configure Azure AD/Entra ID access\n   - Set up RBAC roles for team members\n   - Create service principals for CI/CD\n   - Document access control policies\n\n4. **Network Configuration:**\n   - Plan virtual network topology (if needed)\n   - Configure network security groups\n   - Plan private endpoints strategy\n   - Document network architecture\n\n5. **Governance Setup:**\n   - Apply Azure policies for compliance\n   - Set up management locks for production resources\n   - Configure activity logging\n   - Set up Azure Monitor for resource tracking\n\n## Deliverables\n- [ ] Azure subscription configured and accessible\n- [ ] Resource groups created (dev and prod)\n- [ ] Naming conventions and tagging strategy documented\n- [ ] RBAC roles assigned to team members\n- [ ] Service principals created for automation\n- [ ] Cost alerts configured\n- [ ] Governance policies applied\n- [ ] Network topology documented\n\n## Acceptance Criteria\n- All team members can access Azure subscription with appropriate permissions\n- Resource groups created with proper naming and tags\n- Cost alerts trigger at defined thresholds\n- Service principals can authenticate and access resources\n- Governance policies enforce compliance requirements\n- Documentation complete and accessible to team\n\n## Estimated Effort\n2 days\n\n## Notes\n- Follow Azure naming conventions: https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/naming-and-tagging\n- Consider using Azure landing zones for enterprise deployments\n- Set up separate resource groups for shared resources (networking, monitoring)\n- Use least-privilege principle for RBAC assignments\n- Document all credentials securely (use Azure Key Vault or password manager)\n",
    "labels": [
      "phase-0",
      "azure",
      "critical",
      "1-week"
    ],
    "file_path": "tasks/phase-0-assessment-planning/02-azure-setup.md",
    "phase": "phase-0-assessment-planning",
    "task_number": 2
  },
  {
    "title": "Team Kickoff, Tools Setup, and Access Provisioning",
    "body": "# Task: Team Kickoff, Tools Setup, and Access Provisioning\n\n## Phase\nPhase 0: Assessment and Planning (Week 1, Day 5)\n\n## Description\nConduct team kickoff meeting, set up development tools, and provision access to all required systems.\n\n## Objectives\n- Align team on migration goals and timeline\n- Set up development environments\n- Provision access to all necessary tools and services\n- Establish communication channels and processes\n- Configure development tools and SDKs\n\n## Prerequisites\n- Azure subscription and resource groups configured\n- Project team assigned\n- Migration plan approved\n\n## Dependencies\n- Task 02: Set Up Azure Subscription and Resource Groups\n\n## Tasks\n1. **Team Kickoff Meeting:**\n   - Present migration plan and timeline\n   - Assign roles and responsibilities\n   - Review success criteria and deliverables\n   - Discuss communication protocols\n   - Address team questions and concerns\n   - Schedule regular standup/sync meetings\n\n2. **Development Environment Setup:**\n   - Install .NET 9 SDK\n   - Install Visual Studio 2022 or VS Code\n   - Install Docker Desktop\n   - Install Azure CLI\n   - Install Git and configure SSH keys\n   - Install SQL Server Management Studio or Azure Data Studio\n\n3. **Access Provisioning:**\n   - Provide GitHub repository access to all team members\n   - Grant Azure portal access with appropriate RBAC roles\n   - Provide access to Azure DevOps or GitHub Actions\n   - Set up access to development database\n   - Configure VPN access if required\n\n4. **Tool Configuration:**\n   - Configure Visual Studio with Azure extensions\n   - Set up Azure Storage Explorer\n   - Install Service Bus Explorer\n   - Configure Application Insights extension\n   - Set up code analysis tools (SonarLint, Roslyn analyzers)\n\n5. **Communication Channels:**\n   - Set up team chat channel (Teams, Slack)\n   - Create shared documentation location (SharePoint, Confluence)\n   - Set up project tracking (Azure Boards, GitHub Projects, Jira)\n   - Configure notification preferences\n   - Document escalation procedures\n\n6. **Standards and Guidelines:**\n   - Review coding standards\n   - Review Git workflow and branching strategy\n   - Review pull request process\n   - Review testing requirements\n   - Document development workflow\n\n## Deliverables\n- [ ] Team kickoff meeting completed with documented outcomes\n- [ ] All team members have development environments configured\n- [ ] .NET 9 SDK installed and verified on all dev machines\n- [ ] Azure CLI configured with subscription access\n- [ ] GitHub repository cloned and accessible\n- [ ] Azure portal access verified for all team members\n- [ ] Communication channels established\n- [ ] Project tracking tool configured\n- [ ] Development workflow documented\n\n## Acceptance Criteria\n- All team members can build and run the current application\n- All team members can access Azure resources\n- All team members can push code to repository\n- Communication channels are active and tested\n- Project tracking tool has initial backlog imported\n- Development standards documented and accessible\n- All required tools installed and configured\n\n## Estimated Effort\n1 day\n\n## Notes\n- Provide a setup checklist for each team member\n- Consider pairing new team members with experienced developers\n- Document all tool versions for consistency\n- Create troubleshooting guide for common setup issues\n- Schedule follow-up sessions for tool training if needed\n- Ensure all team members have Azure free credits or appropriate subscription access\n",
    "labels": [
      "phase-0",
      "setup",
      "critical",
      "1-2-days"
    ],
    "file_path": "tasks/phase-0-assessment-planning/03-team-setup.md",
    "phase": "phase-0-assessment-planning",
    "task_number": 3
  },
  {
    "title": "Create Azure Resources (SQL Database, Service Bus, Storage)",
    "body": "# Task: Create Azure Resources (SQL Database, Service Bus, Storage)\n\n## Phase\nPhase 0: Assessment and Planning (Week 2, Day 1-2)\n\n## Description\nProvision all required Azure services for the development environment including SQL Database, Service Bus, and Blob Storage.\n\n## Objectives\n- Create Azure SQL Database for development\n- Set up Azure Service Bus namespace and queue\n- Configure Azure Blob Storage account\n- Establish connectivity and access\n- Document connection strings and configuration\n\n## Prerequisites\n- Azure subscription and resource groups configured\n- Development environment setup complete\n- Application inventory completed (to size resources appropriately)\n\n## Dependencies\n- Task 02: Set Up Azure Subscription and Resource Groups\n- Task 03: Team Kickoff, Tools Setup, and Access Provisioning\n\n## Tasks\n1. **Azure SQL Database Setup:**\n   - Create Azure SQL Database server\n   - Configure server firewall rules (allow Azure services, dev IPs)\n   - Create database with Serverless tier (1 vCore, auto-pause enabled)\n   - Configure geo-redundancy (locally redundant storage for dev)\n   - Create admin credentials and store in Key Vault\n   - Test connectivity from development machines\n   - Document connection string format\n\n2. **Azure Service Bus Setup:**\n   - Create Service Bus namespace (Standard tier)\n   - Create queue for notifications\n   - Configure queue properties (TTL, dead-letter queue, duplicate detection)\n   - Set up access policies (send and receive permissions)\n   - Create connection strings for sending and receiving\n   - Test sending and receiving messages\n   - Document Service Bus configuration\n\n3. **Azure Blob Storage Setup:**\n   - Create Storage Account (Standard tier, locally redundant)\n   - Create blob container for teaching materials\n   - Configure container access level (private)\n   - Set up CORS rules if needed\n   - Generate SAS token for development access\n   - Test file upload and download\n   - Document storage configuration\n\n4. **Azure Key Vault Setup:**\n   - Create Key Vault instance\n   - Store SQL Database connection string\n   - Store Service Bus connection strings\n   - Store Storage Account connection string\n   - Configure access policies for development team\n   - Test secret retrieval\n   - Document Key Vault usage\n\n5. **Network Security:**\n   - Configure firewall rules for SQL Database\n   - Set up private endpoints if required\n   - Configure network security groups\n   - Document security configuration\n\n6. **Monitoring Setup:**\n   - Enable diagnostic logs for all resources\n   - Configure log retention policies\n   - Set up basic alerts (connection failures, resource usage)\n   - Verify metrics are being collected\n\n## Deliverables\n- [ ] Azure SQL Database created and accessible\n- [ ] Azure Service Bus namespace and queue created\n- [ ] Azure Blob Storage account and container created\n- [ ] Azure Key Vault created with all secrets stored\n- [ ] Firewall rules configured for development access\n- [ ] Connection strings documented in Key Vault\n- [ ] All resources tagged appropriately\n- [ ] Diagnostic logging enabled\n- [ ] Basic alerts configured\n- [ ] Resource configuration documented\n\n## Acceptance Criteria\n- SQL Database accessible from development machines\n- Can send and receive messages to Service Bus queue\n- Can upload and download files from Blob Storage\n- All connection strings secured in Key Vault\n- Team members can access resources with appropriate permissions\n- Diagnostic logs are being collected\n- Alerts trigger appropriately for test scenarios\n- All resources follow naming conventions\n\n## Estimated Effort\n2 days\n\n## Notes\n- Use Azure CLI or Azure PowerShell for repeatable resource creation\n- Consider creating ARM templates or Bicep files for infrastructure as code\n- Keep resource costs minimal for development (use smallest tiers)\n- Document resource sizing decisions for later production scaling\n- Test connectivity from different network locations\n- Ensure SQL Database auto-pause is enabled to reduce costs\n- Consider using managed identities instead of connection strings where possible\n- Keep a backup of all configuration settings\n",
    "labels": [
      "phase-0",
      "azure",
      "critical",
      "1-week"
    ],
    "file_path": "tasks/phase-0-assessment-planning/04-create-azure-resources.md",
    "phase": "phase-0-assessment-planning",
    "task_number": 4
  },
  {
    "title": "Set Up GitHub Repository, Branching Strategy, CI/CD Skeleton",
    "body": "# Task: Set Up GitHub Repository, Branching Strategy, CI/CD Skeleton\n\n## Phase\nPhase 0: Assessment and Planning (Week 2, Day 3-4)\n\n## Description\nConfigure GitHub repository structure, establish branching strategy, and create a skeleton CI/CD pipeline using GitHub Actions.\n\n## Objectives\n- Establish Git branching strategy\n- Configure repository settings and protection rules\n- Create initial CI/CD workflows\n- Set up automated build and test pipeline\n- Document Git workflow for the team\n\n## Prerequisites\n- GitHub repository created\n- Team members have repository access\n- Azure resources created (for deployment targets)\n- Development environment setup complete\n\n## Dependencies\n- Task 03: Team Kickoff, Tools Setup, and Access Provisioning\n- Task 04: Create Azure Resources\n\n## Tasks\n1. **Repository Structure:**\n   - Review current repository structure\n   - Create .github directory structure\n   - Set up issue templates\n   - Create pull request template\n   - Add CODEOWNERS file\n   - Configure .gitignore for .NET 9 projects\n\n2. **Branching Strategy:**\n   - Define branching model (e.g., GitFlow, GitHub Flow)\n   - Create main/develop branch structure\n   - Document branch naming conventions (feature/, bugfix/, release/)\n   - Establish merge strategy (squash, rebase, merge commit)\n   - Document workflow in CONTRIBUTING.md\n\n3. **Branch Protection Rules:**\n   - Enable branch protection for main branch\n   - Require pull request reviews (minimum 1 reviewer)\n   - Require status checks to pass before merging\n   - Enable \"Require branches to be up to date\"\n   - Prevent direct pushes to main\n   - Configure administrator enforcement\n\n4. **CI/CD Pipeline - Build Workflow:**\n   - Create .github/workflows/build.yml\n   - Configure triggers (push, pull request)\n   - Set up .NET 9 SDK installation\n   - Add restore, build, and test steps\n   - Configure code coverage reporting\n   - Add build artifact publishing\n\n5. **CI/CD Pipeline - PR Validation:**\n   - Create .github/workflows/pr-validation.yml\n   - Add code quality checks (linting)\n   - Run unit and integration tests\n   - Check for security vulnerabilities\n   - Verify code formatting\n   - Add automated PR comments with results\n\n6. **CI/CD Pipeline - Deploy Skeleton:**\n   - Create .github/workflows/deploy.yml (skeleton)\n   - Define deployment stages (dev, prod)\n   - Set up Azure credentials (Service Principal)\n   - Add manual approval gates for production\n   - Document deployment process\n   - Note: Full deployment steps will be implemented in Phase 4\n\n7. **GitHub Actions Secrets:**\n   - Add Azure credentials as repository secrets\n   - Store connection strings for testing\n   - Configure environment-specific secrets\n   - Document secret management process\n\n8. **Quality Gates:**\n   - Configure status checks required for merging\n   - Set up automated dependency updates (Dependabot)\n   - Enable security alerts\n   - Configure code scanning (CodeQL)\n\n## Deliverables\n- [ ] Branching strategy documented and implemented\n- [ ] Branch protection rules configured\n- [ ] Build workflow (.github/workflows/build.yml) created and tested\n- [ ] PR validation workflow created and tested\n- [ ] Deploy workflow skeleton created\n- [ ] Repository secrets configured\n- [ ] Issue and PR templates created\n- [ ] CODEOWNERS file configured\n- [ ] Dependabot configured\n- [ ] CodeQL scanning enabled\n- [ ] Git workflow documentation (CONTRIBUTING.md)\n\n## Acceptance Criteria\n- Build workflow runs successfully on push and PR\n- All tests pass in CI pipeline\n- Branch protection prevents direct pushes to main\n- PRs require review before merging\n- Code coverage reports are generated\n- Deployment workflow structure is in place (even if not fully functional)\n- All team members understand the Git workflow\n- Documentation is clear and accessible\n\n## Estimated Effort\n2 days\n\n## Notes\n- Use GitHub Actions marketplace for pre-built actions\n- Consider using composite actions for reusable steps\n- Set up notifications for build failures\n- Document how to run workflows locally (using act)\n- Create sample PR to test all checks\n- Ensure CI pipeline runs reasonably fast (< 10 minutes)\n- Consider matrix builds for different configurations\n- Document troubleshooting steps for common CI issues\n",
    "labels": [
      "phase-0",
      "deployment",
      "critical",
      "1-week"
    ],
    "file_path": "tasks/phase-0-assessment-planning/05-github-cicd-setup.md",
    "phase": "phase-0-assessment-planning",
    "task_number": 5
  },
  {
    "title": "Sprint Planning for Phase 1",
    "body": "# Task: Sprint Planning for Phase 1\n\n## Phase\nPhase 0: Assessment and Planning (Week 2, Day 5)\n\n## Description\nConduct sprint planning session to detail Phase 1 tasks, estimate effort, and create the initial sprint backlog.\n\n## Objectives\n- Break down Phase 1 into detailed tasks\n- Estimate effort for each task\n- Identify dependencies and critical path\n- Create sprint backlog\n- Assign initial responsibilities\n- Establish sprint cadence and ceremonies\n\n## Prerequisites\n- Phase 0 tasks completed\n- Team fully onboarded and trained\n- Migration plan reviewed and understood\n- Azure resources available for development\n\n## Dependencies\n- Task 01: Application Inventory and Dependency Analysis\n- Task 02: Set Up Azure Subscription and Resource Groups\n- Task 03: Team Kickoff, Tools Setup, and Access Provisioning\n- Task 04: Create Azure Resources\n- Task 05: Set Up GitHub Repository, Branching Strategy, CI/CD Skeleton\n\n## Tasks\n1. **Review Phase 1 Objectives:**\n   - Review Phase 1 goals from migration plan\n   - Clarify scope and boundaries\n   - Identify potential risks\n   - Review success criteria\n\n2. **Task Breakdown:**\n   - Break down Week 1 (Project Structure) into detailed tasks\n   - Break down Week 2 (Controllers and Views) into detailed tasks\n   - Break down Week 3 (Views and Static Files) into detailed tasks\n   - Break down Week 4 (Data Layer) into detailed tasks\n   - Identify atomic, testable tasks\n   - Create task cards in project tracking tool\n\n3. **Estimation:**\n   - Use planning poker or similar technique for estimation\n   - Estimate each task in story points or hours\n   - Identify complex tasks that need further breakdown\n   - Account for learning curve with new technologies\n   - Add buffer for unknowns (20%)\n\n4. **Dependency Mapping:**\n   - Create task dependency graph\n   - Identify critical path tasks\n   - Highlight blockers and risks\n   - Determine which tasks can run in parallel\n   - Plan for incremental testing\n\n5. **Sprint Organization:**\n   - Define sprint duration (recommended: 2 weeks)\n   - Create Sprint 1 and Sprint 2 backlogs\n   - Assign tasks to team members based on expertise\n   - Balance workload across team\n   - Identify sprint goals\n\n6. **Definition of Done:**\n   - Define what \"done\" means for each task\n   - Establish code review requirements\n   - Define testing requirements\n   - Establish documentation requirements\n   - Document acceptance criteria\n\n7. **Risk Identification:**\n   - Identify technical risks for Phase 1\n   - Plan mitigation strategies\n   - Assign risk owners\n   - Define escalation procedures\n\n8. **Sprint Ceremonies:**\n   - Schedule daily standups\n   - Schedule sprint review/demo\n   - Schedule sprint retrospective\n   - Schedule mid-sprint check-in\n   - Document ceremony formats and expectations\n\n## Deliverables\n- [ ] Detailed Phase 1 task breakdown in project tracking tool\n- [ ] Effort estimates for all Phase 1 tasks\n- [ ] Task dependency graph/diagram\n- [ ] Sprint 1 backlog prioritized and assigned\n- [ ] Sprint 2 backlog prioritized\n- [ ] Definition of Done documented\n- [ ] Risk register for Phase 1\n- [ ] Sprint ceremony schedule\n- [ ] Sprint 1 goal statement\n- [ ] Team capacity planning document\n\n## Acceptance Criteria\n- All Phase 1 tasks from migration plan are represented in backlog\n- Each task has acceptance criteria defined\n- Estimates are reasonable and agreed upon by team\n- Dependencies are clearly identified and documented\n- Sprint backlog is achievable within sprint duration\n- All team members understand their assignments\n- Definition of Done is clear and measurable\n- Risk mitigation strategies are in place\n\n## Estimated Effort\n1 day\n\n## Notes\n- Use collaborative estimation techniques (planning poker)\n- Consider team velocity if known from previous projects\n- Keep sprint backlog flexible to accommodate learnings\n- Don't over-commit in first sprint while team is ramping up\n- Schedule regular backlog refinement sessions\n- Use burndown charts to track progress\n- Document assumptions made during planning\n- Plan for knowledge sharing and pair programming\n- Consider dedicating time for learning .NET 9 features\n- Keep first sprint slightly lighter to account for setup overhead\n",
    "labels": [
      "phase-0",
      "setup",
      "critical",
      "1-2-days"
    ],
    "file_path": "tasks/phase-0-assessment-planning/06-sprint-planning.md",
    "phase": "phase-0-assessment-planning",
    "task_number": 6
  },
  {
    "title": "Create .NET 9 Project Structure",
    "body": "# Task: Create .NET 9 Project Structure\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 1)\n\n## Description\nCreate a new .NET 9 SDK-style project structure to replace the existing .NET Framework 4.8 project.\n\n## Objectives\n- Create new .NET 9 solution and project structure\n- Set up SDK-style project files\n- Establish proper solution organization\n- Configure project settings for ASP.NET Core\n\n## Prerequisites\n- .NET 9 SDK installed\n- Phase 0 completed (development environment ready)\n- Application inventory available\n\n## Dependencies\n- Phase 0: Task 06 - Sprint Planning for Phase 1\n\n## Tasks\n1. **Create Solution Structure:**\n   - Create new solution file (.sln)\n   - Create main web project (ContosoUniversity.Web)\n   - Create test project structure (ContosoUniversity.Tests)\n   - Organize projects in solution folders if needed\n\n2. **Create SDK-Style Project:**\n   - Create new .csproj with SDK-style format\n   - Set TargetFramework to net9.0\n   - Configure project properties (nullable, implicit usings)\n   - Set up output paths and configuration\n\n3. **Project Configuration:**\n   - Configure ASP.NET Core project settings\n   - Set up Razor view compilation\n   - Configure static files directory (wwwroot)\n   - Set up launch settings for development\n\n4. **Initial Dependencies:**\n   - Add core ASP.NET Core MVC packages\n   - Add Entity Framework Core 9 packages\n   - Add logging and configuration packages\n   - Document package versions\n\n5. **Directory Structure:**\n   - Create Controllers directory\n   - Create Models directory\n   - Create Views directory\n   - Create Data directory\n   - Create Services directory\n   - Create wwwroot directory (for static files)\n\n6. **Configuration Files:**\n   - Create Program.cs with minimal setup\n   - Create appsettings.json structure\n   - Create appsettings.Development.json\n   - Set up launchSettings.json\n\n7. **Verify Build:**\n   - Build new project\n   - Run project to verify it starts\n   - Test hot reload functionality\n   - Document any initial issues\n\n## Deliverables\n- [ ] New .NET 9 solution created\n- [ ] SDK-style project file created\n- [ ] Directory structure established\n- [ ] Core NuGet packages added\n- [ ] Program.cs with minimal setup\n- [ ] appsettings.json configured\n- [ ] Project builds successfully\n- [ ] Project runs without errors\n\n## Acceptance Criteria\n- Solution opens in Visual Studio/VS Code without errors\n- Project file is SDK-style format\n- TargetFramework is net9.0\n- Project builds with zero errors\n- Application starts and shows default page\n- All directories follow ASP.NET Core conventions\n- Configuration files are properly formatted\n\n## Estimated Effort\n1-2 days\n\n## Notes\n- Keep old project intact for reference during migration\n- Use SDK-style project format exclusively (not hybrid)\n- Consider enabling nullable reference types from the start\n- Document all project settings and their purposes\n- Create a README in the new project with setup instructions\n- Consider using global.json to lock .NET SDK version\n- Test on multiple developer machines to ensure consistency\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/01-create-dotnet9-project.md",
    "phase": "phase-1-foundation",
    "task_number": 1
  },
  {
    "title": "Migrate packages.config to PackageReference",
    "body": "# Task: Migrate packages.config to PackageReference\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 1)\n\n## Description\nConvert the legacy packages.config format to modern PackageReference format and update all packages to .NET 9 compatible versions.\n\n## Objectives\n- Remove packages.config\n- Migrate to PackageReference format\n- Update packages to .NET 9 compatible versions\n- Resolve package conflicts and dependencies\n- Clean up transitive dependencies\n\n## Prerequisites\n- .NET 9 project structure created\n- Access to NuGet package manager\n- List of current packages from inventory\n\n## Dependencies\n- Phase 1: Task 01 - Create .NET 9 Project Structure\n\n## Tasks\n1. **Inventory Current Packages:**\n   - Extract all packages from packages.config\n   - Document current versions\n   - Identify framework-specific packages\n   - Check compatibility with .NET 9\n\n2. **Remove Legacy Packages:**\n   - Identify packages that are no longer needed\n   - Remove System.Web dependencies\n   - Remove .NET Framework-specific packages\n   - Document removed packages and reasons\n\n3. **Add Core ASP.NET Core Packages:**\n   - Microsoft.AspNetCore.App (SDK reference)\n   - Microsoft.EntityFrameworkCore (9.0.x)\n   - Microsoft.EntityFrameworkCore.SqlServer (9.0.x)\n   - Microsoft.EntityFrameworkCore.Tools (9.0.x)\n\n4. **Add Replacement Packages:**\n   - Replace System.Messaging \u2192 Azure.Messaging.ServiceBus (future)\n   - Replace System.Web.Http \u2192 Microsoft.AspNetCore.Mvc\n   - Replace bundle/minification packages \u2192 WebOptimizer (if needed)\n   - Document all replacements\n\n5. **Add Supporting Packages:**\n   - Microsoft.Extensions.Configuration.Json\n   - Microsoft.Extensions.Logging\n   - Microsoft.Extensions.DependencyInjection\n   - Serilog packages (for structured logging)\n\n6. **Update UI Packages:**\n   - Verify Bootstrap version compatibility\n   - Update jQuery if needed\n   - Document client-side library management strategy\n\n7. **Resolve Conflicts:**\n   - Resolve version conflicts\n   - Handle transitive dependency issues\n   - Test package compatibility\n   - Document any workarounds\n\n8. **Clean Up:**\n   - Delete packages.config\n   - Delete packages directory\n   - Remove legacy references from .csproj\n   - Verify all references are PackageReference\n\n9. **Verify:**\n   - Restore packages successfully\n   - Build project\n   - Check for warnings\n   - Document final package list\n\n## Deliverables\n- [ ] packages.config removed\n- [ ] All packages converted to PackageReference\n- [ ] All packages updated to .NET 9 compatible versions\n- [ ] Package conflicts resolved\n- [ ] Project builds successfully\n- [ ] Package list documented\n- [ ] Migration notes for package changes\n\n## Acceptance Criteria\n- No packages.config file exists\n- All package references use PackageReference format\n- All packages are .NET 9 compatible\n- No package version conflicts\n- Project restores and builds without errors\n- No legacy framework packages remain\n- Documentation explains all major package changes\n\n## Estimated Effort\n1-2 days\n\n## Notes\n- Use Visual Studio's built-in migration tool if available\n- Check for breaking changes in major version updates\n- Some packages may not have .NET 9 versions yet - document alternatives\n- Keep track of packages that need custom replacement logic\n- Test that all functionality still works after package migration\n- Consider using central package management (Directory.Packages.props)\n- Document any packages that require code changes\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/02-migrate-packages.md",
    "phase": "phase-1-foundation",
    "task_number": 2
  },
  {
    "title": "Create Program.cs and Startup Configuration",
    "body": "# Task: Create Program.cs and Startup Configuration\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 1)\n\n## Description\nCreate the Program.cs file with proper ASP.NET Core startup configuration, middleware pipeline, and dependency injection setup.\n\n## Objectives\n- Create Program.cs with minimal hosting model\n- Configure services and dependency injection\n- Set up middleware pipeline\n- Configure routing and MVC\n- Replace Global.asax functionality\n\n## Prerequisites\n- .NET 9 project structure created\n- Packages migrated to PackageReference\n- Understanding of current Global.asax setup\n\n## Dependencies\n- Phase 1: Task 01 - Create .NET 9 Project Structure\n- Phase 1: Task 02 - Migrate packages.config to PackageReference\n\n## Tasks\n1. **Create Program.cs:**\n   - Use minimal hosting model (WebApplication.CreateBuilder)\n   - Set up web application builder\n   - Configure Kestrel settings\n   - Set up logging configuration\n\n2. **Configure Services (Dependency Injection):**\n   - Add MVC services (AddControllersWithViews)\n   - Configure Razor Pages options\n   - Add session services if needed\n   - Add health checks\n   - Add HTTP client factory\n   - Prepare for future service registrations\n\n3. **Configure Middleware Pipeline:**\n   - Add exception handling middleware\n   - Add HTTPS redirection\n   - Add static files middleware\n   - Add routing middleware\n   - Add authentication middleware (placeholder)\n   - Add authorization middleware\n   - Add session middleware if needed\n\n4. **Configure Routing:**\n   - Set up conventional routing\n   - Define default route pattern\n   - Configure area routes if needed\n   - Map controllers\n\n5. **Environment-Specific Configuration:**\n   - Configure development exception page\n   - Set up error handling for production\n   - Configure different behaviors per environment\n\n6. **Replace Global.asax Functionality:**\n   - Move application start logic\n   - Convert filters to middleware\n   - Replace route configuration\n   - Convert bundling configuration (if applicable)\n\n7. **Configuration Setup:**\n   - Load appsettings.json\n   - Load environment-specific settings\n   - Set up environment variables\n   - Configure options pattern for settings\n\n8. **Logging Configuration:**\n   - Set up default logging providers\n   - Configure log levels\n   - Prepare for Application Insights integration (Phase 3)\n\n## Deliverables\n- [ ] Program.cs created with full configuration\n- [ ] Services properly registered in DI container\n- [ ] Middleware pipeline configured correctly\n- [ ] Routing configured with default patterns\n- [ ] Environment-specific behavior implemented\n- [ ] Global.asax functionality migrated\n- [ ] Application starts without errors\n- [ ] Configuration is well-documented\n\n## Acceptance Criteria\n- Application starts and runs successfully\n- Default route works (HomeController/Index)\n- Static files are served correctly\n- Error pages display appropriately\n- Development vs Production behavior differs correctly\n- All services are properly registered\n- No Global.asax or App_Start files remain\n- Code is well-commented and documented\n\n## Estimated Effort\n1-2 days\n\n## Notes\n- Use minimal hosting model for cleaner code\n- Keep middleware order correct (exception handling \u2192 static files \u2192 routing \u2192 auth \u2192 MVC)\n- Use built-in DI container instead of third-party containers initially\n- Consider using IHostBuilder extensions for better organization\n- Document service lifetimes (Singleton, Scoped, Transient)\n- Test hot reload functionality works properly\n- Consider using top-level statements for cleaner Program.cs\n- Add comments explaining each middleware's purpose\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/03-program-startup.md",
    "phase": "phase-1-foundation",
    "task_number": 3
  },
  {
    "title": "Convert Web.config to appsettings.json",
    "body": "# Task: Convert Web.config to appsettings.json\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 1)\n\n## Description\nMigrate configuration from Web.config to the modern appsettings.json format and implement the IConfiguration pattern.\n\n## Objectives\n- Extract all configuration from Web.config\n- Create appsettings.json structure\n- Implement environment-specific configuration\n- Replace ConfigurationManager with IConfiguration\n- Secure sensitive configuration\n\n## Prerequisites\n- Program.cs created\n- Understanding of current Web.config settings\n- Azure Key Vault ready (from Phase 0)\n\n## Dependencies\n- Phase 1: Task 03 - Create Program.cs and Startup Configuration\n- Phase 0: Task 04 - Create Azure Resources\n\n## Tasks\n1. **Analyze Web.config:**\n   - Extract all appSettings\n   - Extract connection strings\n   - Identify authentication settings\n   - Document custom configuration sections\n   - Note system.web settings\n\n2. **Create appsettings.json:**\n   - Create main appsettings.json\n   - Structure configuration hierarchically\n   - Add connection strings section\n   - Add application-specific settings\n   - Add logging configuration\n\n3. **Create Environment-Specific Settings:**\n   - Create appsettings.Development.json\n   - Create appsettings.Production.json (template)\n   - Document environment overrides\n   - Set up proper file precedence\n\n4. **Migrate Configuration Sections:**\n   - Migrate connection strings:\n     ```json\n     {\n       \"ConnectionStrings\": {\n         \"DefaultConnection\": \"Server=...\"\n       }\n     }\n     ```\n   - Migrate app settings:\n     ```json\n     {\n       \"NotificationQueuePath\": \"...\",\n       \"UploadPath\": \"...\"\n     }\n     ```\n\n5. **Configure Options Pattern:**\n   - Create strongly-typed configuration classes\n   - Register options in DI container\n   - Implement IOptions<T> pattern\n   - Validate configuration on startup\n\n6. **Secure Sensitive Settings:**\n   - Identify secrets (connection strings, keys)\n   - Document which settings should come from Key Vault\n   - Use user secrets for local development\n   - Configure Azure Key Vault integration (Phase 2)\n\n7. **Update Code References:**\n   - Find all ConfigurationManager.AppSettings references\n   - Replace with IConfiguration injection\n   - Update connection string retrieval\n   - Test all configuration reads\n\n8. **Environment Variables:**\n   - Document environment variable overrides\n   - Set up local development variables\n   - Configure Azure App Service settings (Phase 4)\n\n9. **Remove Web.config:**\n   - Remove system.web sections\n   - Keep only necessary runtime settings (if any)\n   - Document what was removed\n   - Verify nothing is broken\n\n## Deliverables\n- [ ] appsettings.json created with all configuration\n- [ ] appsettings.Development.json created\n- [ ] Environment-specific configuration working\n- [ ] Strongly-typed configuration classes created\n- [ ] IConfiguration used throughout codebase\n- [ ] ConfigurationManager references removed\n- [ ] User secrets configured for development\n- [ ] Configuration documentation updated\n\n## Acceptance Criteria\n- All configuration from Web.config is migrated\n- Application reads configuration correctly\n- Environment-specific overrides work\n- No ConfigurationManager references remain\n- Configuration is strongly-typed where possible\n- Sensitive data is not in appsettings.json\n- User secrets work for local development\n- Documentation explains configuration structure\n\n## Estimated Effort\n1-2 days\n\n## Notes\n- Use user secrets (dotnet user-secrets) for local development\n- Never commit sensitive data to source control\n- Use hierarchical JSON structure for better organization\n- Consider using IOptionsSnapshot for hot-reload scenarios\n- Validate configuration on startup to fail fast\n- Document all configuration options and their defaults\n- Use consistent naming conventions (PascalCase recommended)\n- Consider creating configuration validation attributes\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/04-config-migration.md",
    "phase": "phase-1-foundation",
    "task_number": 4
  },
  {
    "title": "Set Up Dependency Injection Container",
    "body": "# Task: Set Up Dependency Injection Container\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 1)\n\n## Description\nConfigure the built-in dependency injection container and register all services, replacing manual instantiation and static factories.\n\n## Objectives\n- Configure DI container in Program.cs\n- Register DbContext with proper lifetime\n- Register services with appropriate lifetimes\n- Remove static factory patterns\n- Enable constructor injection throughout\n\n## Prerequisites\n- Program.cs created\n- Configuration system set up\n- Understanding of current service instantiation\n\n## Dependencies\n- Phase 1: Task 03 - Create Program.cs and Startup Configuration\n- Phase 1: Task 04 - Convert Web.config to appsettings.json\n\n## Tasks\n1. **Understand Current Service Creation:**\n   - Identify all manual instantiations\n   - Document BaseController pattern\n   - Find all static factory patterns\n   - List all services that need registration\n\n2. **Register DbContext:**\n   - Add SchoolContext to DI container\n   - Configure lifetime (Scoped recommended)\n   - Set up connection string from configuration\n   - Remove SchoolContextFactory pattern\n   ```csharp\n   builder.Services.AddDbContext<SchoolContext>(options =>\n       options.UseSqlServer(\n           builder.Configuration.GetConnectionString(\"DefaultConnection\")\n       )\n   );\n   ```\n\n3. **Register Application Services:**\n   - Register NotificationService (Scoped)\n   - Register any other business services\n   - Prepare for future service registrations\n   - Document service lifetimes\n\n4. **Service Lifetime Decisions:**\n   - Singleton: Stateless services, shared state\n   - Scoped: Per-request services (DbContext, most services)\n   - Transient: Lightweight, stateless services\n   - Document lifetime choices\n\n5. **Create Service Interfaces:**\n   - Create INotificationService interface\n   - Create other service interfaces as needed\n   - Register interfaces with implementations\n   - Enable testability through interfaces\n\n6. **Configure Service Options:**\n   - Register configuration options\n   - Use IOptions<T> pattern\n   - Validate options on startup\n   ```csharp\n   builder.Services.Configure<NotificationOptions>(\n       builder.Configuration.GetSection(\"Notification\")\n   );\n   ```\n\n7. **HttpClient Configuration:**\n   - Register IHttpClientFactory\n   - Configure named or typed clients\n   - Set up default policies (retry, timeout)\n\n8. **Logging Configuration:**\n   - Register logging services\n   - Configure log providers\n   - Set up structured logging (Serilog prep)\n\n9. **Remove Static Factories:**\n   - Remove SchoolContextFactory.Create()\n   - Remove other static factory methods\n   - Update code to use injected services\n\n10. **Testing Setup:**\n    - Verify services are resolvable\n    - Test service lifetimes\n    - Check for circular dependencies\n    - Document DI container configuration\n\n## Deliverables\n- [ ] DI container fully configured in Program.cs\n- [ ] DbContext registered with proper lifetime\n- [ ] All services registered in DI container\n- [ ] Service interfaces created\n- [ ] Static factories removed\n- [ ] Configuration options registered\n- [ ] Service lifetimes documented\n- [ ] DI configuration tested and verified\n\n## Acceptance Criteria\n- All services can be resolved from DI container\n- No circular dependency errors\n- DbContext is properly scoped to requests\n- Services have appropriate lifetimes\n- No static factory patterns remain\n- Configuration options are properly bound\n- Code is ready for constructor injection\n- Documentation explains DI decisions\n\n## Estimated Effort\n1 day\n\n## Notes\n- Use constructor injection exclusively\n- Avoid service locator pattern\n- Prefer interfaces over concrete types for flexibility\n- Be careful with Captive Dependencies (don't inject Scoped into Singleton)\n- Use IServiceScope for creating scopes manually when needed\n- Consider using Scrutor for assembly scanning if many services\n- Test DI configuration in integration tests\n- Document any complex service registrations\n- Use extension methods to organize service registrations\n",
    "labels": [
      "phase-1",
      "deployment",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/05-dependency-injection.md",
    "phase": "phase-1-foundation",
    "task_number": 5
  },
  {
    "title": "Migrate Controllers to ASP.NET Core MVC",
    "body": "# Task: Migrate Controllers to ASP.NET Core MVC\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 2)\n\n## Description\nMigrate all controllers from ASP.NET MVC 5 to ASP.NET Core MVC, updating them to use dependency injection and modern patterns.\n\n## Objectives\n- Migrate BaseController functionality\n- Convert all controllers to use IActionResult\n- Implement constructor injection\n- Update action methods for ASP.NET Core\n- Remove System.Web dependencies\n\n## Prerequisites\n- .NET 9 project structure ready\n- Dependency injection configured\n- Configuration system migrated\n- Understanding of current controller architecture\n\n## Dependencies\n- Phase 1: Task 05 - Set Up Dependency Injection Container\n\n## Tasks\n1. **Analyze Current Controllers:**\n   - List all controllers (Students, Courses, Instructors, Departments, Home, Notifications)\n   - Document BaseController pattern and its purpose\n   - Identify System.Web dependencies\n   - Note async/sync patterns\n\n2. **Migrate BaseController:**\n   - Remove BaseController inheritance pattern\n   - Move DbContext to constructor injection\n   - Move NotificationService to constructor injection\n   - Create shared controller functionality (base class or helper methods)\n   ```csharp\n   public class BaseController : Controller\n   {\n       protected readonly SchoolContext _context;\n       protected readonly INotificationService _notifications;\n       \n       public BaseController(SchoolContext context, INotificationService notifications)\n       {\n           _context = context;\n           _notifications = notifications;\n       }\n   }\n   ```\n\n3. **Migrate HomeController:**\n   - Convert to ASP.NET Core Controller\n   - Update Index action\n   - Update About action\n   - Update Contact action\n   - Test routing works\n\n4. **Migrate StudentsController:**\n   - Update namespace imports\n   - Change ActionResult to IActionResult\n   - Add constructor with dependencies\n   - Update Index (list with pagination)\n   - Update Details\n   - Update Create (GET and POST)\n   - Update Edit (GET and POST)\n   - Update Delete (GET and POST)\n   - Convert synchronous methods to async\n\n5. **Migrate CoursesController:**\n   - Follow same pattern as StudentsController\n   - Handle file upload for teaching materials (stub for Phase 2)\n   - Update CRUD operations\n   - Test all actions\n\n6. **Migrate InstructorsController:**\n   - Migrate CRUD operations\n   - Handle complex related data loading\n   - Update view models if needed\n   - Test functionality\n\n7. **Migrate DepartmentsController:**\n   - Migrate CRUD operations\n   - Handle optimistic concurrency\n   - Update error handling\n   - Test functionality\n\n8. **Migrate NotificationsController:**\n   - Migrate notification retrieval\n   - Update API methods\n   - Prepare for Azure Service Bus (Phase 2)\n   - Test basic functionality\n\n9. **Update Action Results:**\n   - Replace ActionResult with IActionResult\n   - Use typed results (ViewResult, JsonResult, etc.)\n   - Update redirect methods\n   - Update error handling\n\n10. **Remove System.Web Dependencies:**\n    - Replace HttpContext.Current with injected IHttpContextAccessor\n    - Update file upload methods\n    - Remove Server.MapPath usage\n    - Update URL generation\n\n11. **Update Model Binding:**\n    - Verify [FromBody], [FromQuery], [FromRoute] attributes\n    - Update custom model binders if any\n    - Test model validation\n\n12. **Update Filters:**\n    - Convert filter attributes to ASP.NET Core\n    - Implement custom filters if needed\n    - Test filter execution\n\n## Deliverables\n- [ ] BaseController pattern updated or removed\n- [ ] HomeController migrated and tested\n- [ ] StudentsController migrated and tested\n- [ ] CoursesController migrated and tested\n- [ ] InstructorsController migrated and tested\n- [ ] DepartmentsController migrated and tested\n- [ ] NotificationsController migrated and tested\n- [ ] All controllers use constructor injection\n- [ ] All actions return IActionResult\n- [ ] System.Web dependencies removed\n- [ ] Basic navigation works\n\n## Acceptance Criteria\n- All controllers compile without errors\n- All controllers use constructor injection\n- No System.Web namespaces remain\n- All action methods return IActionResult or derived types\n- Basic CRUD operations work (with existing views)\n- Routing works correctly\n- Error handling is functional\n- No BaseController anti-pattern remains\n\n## Estimated Effort\n3-4 days\n\n## Notes\n- Migrate controllers incrementally and test each one\n- Keep old controllers for reference until migration is complete\n- Use async/await throughout (convert synchronous methods)\n- Pay attention to model binding differences\n- Test each controller after migration\n- Update XML comments and documentation\n- Consider using API analyzers for best practices\n- Document any breaking changes or workarounds needed\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "3-4-days"
    ],
    "file_path": "tasks/phase-1-foundation/06-migrate-controllers.md",
    "phase": "phase-1-foundation",
    "task_number": 6
  },
  {
    "title": "Update Routing to ASP.NET Core Conventions",
    "body": "# Task: Update Routing to ASP.NET Core Conventions\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 2)\n\n## Description\nUpdate routing from ASP.NET MVC 5 RouteConfig to ASP.NET Core routing conventions and middleware.\n\n## Objectives\n- Remove RouteConfig.cs\n- Configure routing in Program.cs\n- Set up conventional routing\n- Configure attribute routing\n- Test all routes work correctly\n\n## Prerequisites\n- Controllers migrated to ASP.NET Core\n- Program.cs configured\n- Understanding of current routing configuration\n\n## Dependencies\n- Phase 1: Task 06 - Migrate Controllers to ASP.NET Core MVC\n\n## Tasks\n1. **Analyze Current Routing:**\n   - Review RouteConfig.cs\n   - Document custom routes\n   - Identify route constraints\n   - Note default routes\n\n2. **Configure Routing in Program.cs:**\n   - Add routing middleware to pipeline\n   - Configure endpoint routing\n   - Set up conventional routes\n   ```csharp\n   app.MapControllerRoute(\n       name: \"default\",\n       pattern: \"{controller=Home}/{action=Index}/{id?}\");\n   ```\n\n3. **Set Up Area Routes (if applicable):**\n   - Configure area routing\n   - Set up area-specific routes\n   - Test area routing\n\n4. **Configure Attribute Routing:**\n   - Update controllers to use [Route] attributes where needed\n   - Add [HttpGet], [HttpPost] attributes\n   - Use route templates for API-like controllers\n   - Test attribute routes\n\n5. **Configure Route Constraints:**\n   - Add route constraints if needed\n   - Configure parameter constraints\n   - Test constraint validation\n\n6. **Update Link Generation:**\n   - Test Url.Action() calls\n   - Test Html.ActionLink() calls\n   - Update any hardcoded URLs\n   - Verify all links work\n\n7. **Configure Lowercased URLs (optional):**\n   ```csharp\n   builder.Services.Configure<RouteOptions>(options =>\n   {\n       options.LowercaseUrls = true;\n       options.LowercaseQueryStrings = false;\n   });\n   ```\n\n8. **Remove Old Routing:**\n   - Delete RouteConfig.cs\n   - Remove App_Start folder if empty\n   - Clean up old routing references\n\n9. **Test Routing:**\n   - Test all major routes manually\n   - Verify default route works\n   - Test parameterized routes\n   - Test route constraints\n   - Verify 404 handling\n\n## Deliverables\n- [ ] Routing configured in Program.cs\n- [ ] RouteConfig.cs removed\n- [ ] Default route works correctly\n- [ ] All controller actions are routable\n- [ ] Attribute routing configured where needed\n- [ ] Link generation works correctly\n- [ ] Route constraints functional\n- [ ] 404 pages display correctly\n\n## Acceptance Criteria\n- All pages accessible via correct URLs\n- No broken links in navigation\n- Default route (/) navigates to Home/Index\n- Parameterized routes work (e.g., /Students/Details/1)\n- RouteConfig.cs and App_Start removed\n- URL generation methods work correctly\n- Routing is well-documented\n\n## Estimated Effort\n1 day\n\n## Notes\n- ASP.NET Core uses endpoint routing by default\n- Middleware order matters: UseRouting() before UseEndpoints()\n- Use attribute routing for API-style controllers\n- Use conventional routing for MVC-style controllers\n- Test routing with different URL patterns\n- Consider using lowercase URLs for consistency\n- Document any custom route configurations\n- Use route names for generating URLs reliably\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/07-update-routing.md",
    "phase": "phase-1-foundation",
    "task_number": 7
  },
  {
    "title": "Migrate Razor Views to ASP.NET Core",
    "body": "# Task: Migrate Razor Views to ASP.NET Core\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 3)\n\n## Description\nMigrate all Razor views from ASP.NET MVC 5 to ASP.NET Core, updating view syntax, helpers, and tag helpers.\n\n## Objectives\n- Migrate _ViewStart and _Layout files\n- Convert HTML helpers to tag helpers\n- Update all view files\n- Move static files to wwwroot\n- Update script and style references\n\n## Prerequisites\n- Controllers migrated and functional\n- Static files middleware configured\n- Understanding of tag helper syntax\n\n## Dependencies\n- Phase 1: Task 06 - Migrate Controllers to ASP.NET Core MVC\n- Phase 1: Task 07 - Update Routing to ASP.NET Core Conventions\n\n## Tasks\n1. **Analyze Current Views:**\n   - List all views and their dependencies\n   - Document current HTML helper usage\n   - Identify custom helpers\n   - Note bundling and script references\n\n2. **Migrate _ViewStart.cshtml:**\n   - Copy to Views folder\n   - Verify Layout path\n   - Test that layout is applied\n\n3. **Migrate _Layout.cshtml:**\n   - Update DOCTYPE and HTML structure\n   - Remove @Styles.Render() and @Scripts.Render()\n   - Add link tags for CSS files\n   - Add script tags for JavaScript files\n   - Update navigation menu\n   - Update @RenderBody(), @RenderSection()\n   - Add environment tag helper for dev/prod assets\n   ```cshtml\n   <environment include=\"Development\">\n       <link rel=\"stylesheet\" href=\"~/css/site.css\" />\n   </environment>\n   <environment exclude=\"Development\">\n       <link rel=\"stylesheet\" href=\"~/css/site.min.css\" />\n   </environment>\n   ```\n\n4. **Migrate _ViewImports.cshtml:**\n   - Create _ViewImports.cshtml\n   - Add @using statements for namespaces\n   - Add @addTagHelper directives\n   ```cshtml\n   @using ContosoUniversity.Models\n   @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers\n   ```\n\n5. **Convert Form Helpers:**\n   - Replace @Html.BeginForm() with <form asp-controller=\"\" asp-action=\"\">\n   - Update form method and attributes\n   - Test form submissions\n\n6. **Convert Input Helpers:**\n   - Replace @Html.TextBoxFor() with <input asp-for=\"\" />\n   - Replace @Html.EditorFor() with <input asp-for=\"\" />\n   - Replace @Html.DropDownListFor() with <select asp-for=\"\" asp-items=\"\">\n   - Update input attributes and classes\n\n7. **Convert Validation Helpers:**\n   - Replace @Html.ValidationMessageFor() with <span asp-validation-for=\"\" />\n   - Replace @Html.ValidationSummary() with <div asp-validation-summary=\"\" />\n   - Keep validation scripts\n\n8. **Convert Link Helpers:**\n   - Replace @Html.ActionLink() with <a asp-controller=\"\" asp-action=\"\">\n   - Update link parameters\n   - Test all links\n\n9. **Convert Display Helpers:**\n   - Update @Html.DisplayFor() usage\n   - Update @Html.DisplayNameFor() usage\n   - Keep these helpers or replace with direct model references\n\n10. **Migrate All Views by Controller:**\n    - Home views (Index, About, Contact)\n    - Students views (Index, Details, Create, Edit, Delete)\n    - Courses views (Index, Details, Create, Edit, Delete)\n    - Instructors views (Index, Details, Create, Edit, Delete)\n    - Departments views (Index, Details, Create, Edit, Delete)\n    - Shared views (_ValidationScriptsPartial, Error, etc.)\n\n11. **Update Script References:**\n    - Update jQuery reference\n    - Update validation script references\n    - Update custom script references\n    - Test client-side validation\n\n12. **Test Each View:**\n    - Verify view renders correctly\n    - Test form submission\n    - Test validation\n    - Test links and navigation\n    - Verify styling is correct\n\n## Deliverables\n- [ ] _ViewStart.cshtml migrated\n- [ ] _Layout.cshtml migrated with tag helpers\n- [ ] _ViewImports.cshtml created\n- [ ] All Home views migrated\n- [ ] All Students views migrated\n- [ ] All Courses views migrated\n- [ ] All Instructors views migrated\n- [ ] All Departments views migrated\n- [ ] All shared views migrated\n- [ ] HTML helpers converted to tag helpers\n- [ ] All forms functional\n- [ ] All validation working\n\n## Acceptance Criteria\n- All views render without errors\n- No HTML helper syntax remains (except DisplayFor/DisplayNameFor if kept)\n- Tag helpers work correctly\n- Forms submit successfully\n- Client-side validation works\n- All links navigate correctly\n- Views follow ASP.NET Core conventions\n- Styling is preserved\n\n## Estimated Effort\n3-4 days\n\n## Notes\n- Migrate views incrementally, one controller at a time\n- Test each view after migration\n- Tag helpers are more HTML-like and easier to read\n- Keep validation scripts (_ValidationScriptsPartial.cshtml)\n- Use environment tag helper for dev vs prod assets\n- Document any custom tag helpers needed\n- Consider using Razor Class Library for shared components\n- Test both client-side and server-side validation\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "3-4-days"
    ],
    "file_path": "tasks/phase-1-foundation/08-migrate-views.md",
    "phase": "phase-1-foundation",
    "task_number": 8
  },
  {
    "title": "Move Static Files to wwwroot and Configure Static File Serving",
    "body": "# Task: Move Static Files to wwwroot and Configure Static File Serving\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 3)\n\n## Description\nMove all static files (CSS, JavaScript, images) from Content/ and Scripts/ to wwwroot/ and configure static file middleware.\n\n## Objectives\n- Create wwwroot directory structure\n- Move CSS files from Content/ to wwwroot/css/\n- Move JavaScript files from Scripts/ to wwwroot/js/\n- Move images and other assets\n- Configure static file middleware\n- Update references in views\n\n## Prerequisites\n- Views migrated to ASP.NET Core\n- Static files middleware added to Program.cs\n- Understanding of current static file organization\n\n## Dependencies\n- Phase 1: Task 08 - Migrate Razor Views to ASP.NET Core\n\n## Tasks\n1. **Create wwwroot Structure:**\n   - Create wwwroot/css directory\n   - Create wwwroot/js directory\n   - Create wwwroot/lib directory (for third-party libraries)\n   - Create wwwroot/images directory\n   - Create wwwroot/uploads directory (placeholder)\n\n2. **Move CSS Files:**\n   - Move all files from Content/ to wwwroot/css/\n   - Preserve folder structure if any\n   - Update CSS file references\n   - Test CSS loading\n\n3. **Move JavaScript Files:**\n   - Move all files from Scripts/ to wwwroot/js/\n   - Organize JavaScript files logically\n   - Keep jQuery and Bootstrap in wwwroot/lib/\n   - Update script references\n\n4. **Move Images and Icons:**\n   - Move images to wwwroot/images/\n   - Move favicons to wwwroot/\n   - Update image references in views and CSS\n\n5. **Configure Static Files Middleware:**\n   - Already added in Program.cs\n   - Configure default files if needed\n   - Set up static file options (caching, MIME types)\n   ```csharp\n   app.UseStaticFiles(new StaticFileOptions\n   {\n       OnPrepareResponse = ctx =>\n       {\n           // Set cache headers\n           ctx.Context.Response.Headers.Append(\"Cache-Control\", \"public,max-age=600\");\n       }\n   });\n   ```\n\n6. **Update View References:**\n   - Update all link tags in _Layout.cshtml\n   - Update all script tags\n   - Use ~ prefix for root-relative paths\n   - Test all references work\n\n7. **Client-Side Library Management:**\n   - Consider using libman for client-side libraries\n   - Create libman.json if using libman\n   - Or keep CDN references with local fallbacks\n   - Document library management strategy\n\n8. **Remove Old Directories:**\n   - Delete Content/ directory\n   - Delete Scripts/ directory  \n   - Remove App_Start/BundleConfig.cs (if exists)\n   - Clean up project structure\n\n9. **Test Static Files:**\n   - Verify all CSS loads correctly\n   - Verify all JavaScript loads correctly\n   - Test images display properly\n   - Check browser console for 404 errors\n\n## Deliverables\n- [ ] wwwroot directory created with proper structure\n- [ ] All CSS files moved to wwwroot/css/\n- [ ] All JavaScript files moved to wwwroot/js/\n- [ ] All images moved to wwwroot/images/\n- [ ] Static file middleware configured\n- [ ] All view references updated\n- [ ] Old Content/ and Scripts/ directories removed\n- [ ] No broken static file references\n\n## Acceptance Criteria\n- Application styling renders correctly\n- No CSS or JavaScript 404 errors\n- Images display properly\n- Static files are served correctly\n- No old Content/ or Scripts/ directories exist\n- Client-side functionality works (validation, etc.)\n- Browser console shows no errors\n\n## Estimated Effort\n1 day\n\n## Notes\n- Use wwwroot convention for all static files\n- Consider using CDN for popular libraries (jQuery, Bootstrap)\n- Set up proper caching headers for production\n- Use environment tag helper to switch between dev and production assets\n- Consider minification and bundling strategy (WebOptimizer, Webpack, etc.)\n- Test on different browsers to ensure cross-browser compatibility\n- Document where to place future static files\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/09-move-static-files.md",
    "phase": "phase-1-foundation",
    "task_number": 9
  },
  {
    "title": "Update Entity Framework Core to Version 9",
    "body": "# Task: Update Entity Framework Core to Version 9\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 4)\n\n## Description\nUpdate Entity Framework Core from version 3.1 to version 9, ensuring compatibility and taking advantage of new features.\n\n## Objectives\n- Update EF Core packages to version 9\n- Update DbContext for .NET 9\n- Review and update LINQ queries for EF Core 9\n- Test all database operations\n- Document breaking changes\n\n## Prerequisites\n- .NET 9 project created\n- Packages migrated to PackageReference\n- Database schema understood from inventory\n- Dependency injection configured\n\n## Dependencies\n- Phase 1: Task 05 - Set Up Dependency Injection Container\n\n## Tasks\n1. **Update EF Core Packages:**\n   - Update Microsoft.EntityFrameworkCore to 9.0.x\n   - Update Microsoft.EntityFrameworkCore.SqlServer to 9.0.x\n   - Update Microsoft.EntityFrameworkCore.Tools to 9.0.x\n   - Update Microsoft.EntityFrameworkCore.Design to 9.0.x (if used)\n\n2. **Review Breaking Changes:**\n   - Review EF Core 9 breaking changes documentation\n   - Identify affected code in SchoolContext\n   - Document required changes\n   - Plan migration approach\n\n3. **Update SchoolContext:**\n   - Keep DbContext configuration\n   - Update OnModelCreating if needed\n   - Review entity configurations\n   - Update any custom conventions\n   - Verify connection string configuration\n\n4. **Update Entity Configurations:**\n   - Review all entity type configurations\n   - Update any deprecated APIs\n   - Test TPH (Table-per-Hierarchy) inheritance for Person/Student/Instructor\n   - Verify relationships and navigation properties\n\n5. **Review LINQ Queries:**\n   - Identify all LINQ queries in controllers\n   - Test queries with EF Core 9\n   - Update queries if translation issues occur\n   - Look for N+1 query problems\n   - Add .Include() where needed for related data\n\n6. **Update Query Methods:**\n   - Ensure efficient query patterns\n   - Use AsNoTracking() for read-only queries\n   - Use proper async methods (ToListAsync, FirstOrDefaultAsync)\n   - Optimize complex queries\n\n7. **Test DateTime Handling:**\n   - Verify datetime2 handling\n   - Test timezone scenarios\n   - Check for any date formatting issues\n\n8. **Performance Testing:**\n   - Compare query performance with old version\n   - Check for query regression\n   - Use SQL Server Profiler or logging to inspect generated SQL\n   - Optimize slow queries\n\n9. **Test All Database Operations:**\n   - Test Create operations\n   - Test Read operations (list, details)\n   - Test Update operations\n   - Test Delete operations\n   - Test complex queries (pagination, filtering, sorting)\n   - Test related data loading\n\n## Deliverables\n- [ ] EF Core packages updated to version 9\n- [ ] SchoolContext updated and functional\n- [ ] Breaking changes addressed\n- [ ] All LINQ queries reviewed and tested\n- [ ] Database operations tested\n- [ ] Performance verified\n- [ ] Migration notes documented\n\n## Acceptance Criteria\n- All EF Core packages are version 9.0.x\n- SchoolContext compiles without errors\n- All database operations work correctly\n- No query translation errors\n- Performance is acceptable\n- TPH inheritance works correctly\n- Navigation properties load correctly\n- Documentation covers all changes made\n\n## Estimated Effort\n1-2 days\n\n## Notes\n- EF Core 9 has many performance improvements\n- Review the release notes for new features to leverage\n- Use logging to see generated SQL during testing\n- Consider using compiled queries for frequently used queries\n- Test with realistic data volumes\n- Document any workarounds needed\n- Keep database connection strings in configuration, not code\n- Use migrations for schema changes (next task)\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/10-update-ef-core.md",
    "phase": "phase-1-foundation",
    "task_number": 10
  },
  {
    "title": "Update DbContext for Dependency Injection and Remove Static Factory",
    "body": "# Task: Update DbContext for Dependency Injection and Remove Static Factory\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 4)\n\n## Description\nRemove the SchoolContextFactory static factory pattern and update DbContext to use dependency injection properly.\n\n## Objectives\n- Remove SchoolContextFactory class\n- Register DbContext in DI container\n- Update all DbContext usage to use injected instances\n- Implement proper DbContext lifetime management\n- Test connection pooling and performance\n\n## Prerequisites\n- EF Core updated to version 9\n- Dependency injection container configured\n- Understanding of DbContext lifetime management\n\n## Dependencies\n- Phase 1: Task 10 - Update Entity Framework Core to Version 9\n\n## Tasks\n1. **Analyze Current Factory Usage:**\n   - Find all SchoolContextFactory.Create() calls\n   - Document where DbContext is created\n   - Identify patterns of usage\n   - Note disposal patterns\n\n2. **Remove SchoolContextFactory:**\n   - Delete SchoolContextFactory class\n   - Remove design-time factory if not needed\n   - Document removal\n\n3. **Register DbContext in DI:**\n   - Already done in Task 05, verify configuration\n   ```csharp\n   builder.Services.AddDbContext<SchoolContext>(options =>\n       options.UseSqlServer(\n           builder.Configuration.GetConnectionString(\"DefaultConnection\"),\n           sqlOptions => sqlOptions.EnableRetryOnFailure()\n       )\n   );\n   ```\n\n4. **Configure DbContext Options:**\n   - Enable sensitive data logging for development\n   - Configure query tracking behavior\n   - Set command timeout if needed\n   - Configure connection resiliency\n   ```csharp\n   options.UseSqlServer(connectionString, sqlOptions =>\n   {\n       sqlOptions.EnableRetryOnFailure(\n           maxRetryCount: 5,\n           maxRetryDelay: TimeSpan.FromSeconds(30),\n           errorNumbersToAdd: null);\n   });\n   ```\n\n5. **Update Controllers:**\n   - Remove manual DbContext instantiation\n   - Use injected DbContext from constructor\n   - Verify DbContext is disposed properly (automatic with DI)\n   - Test each controller\n\n6. **Update Services:**\n   - Inject DbContext into NotificationService\n   - Update any other services using DbContext\n   - Ensure proper lifetime scopes\n\n7. **Test DbContext Lifetime:**\n   - Verify DbContext is scoped per request\n   - Test concurrent requests\n   - Verify no connection leaks\n   - Check connection pooling is working\n\n8. **Test Database Operations:**\n   - Test CRUD operations\n   - Test concurrent database access\n   - Verify transactions work correctly\n   - Test error handling and retries\n\n9. **Performance Testing:**\n   - Compare connection pooling performance\n   - Verify no connection exhaustion\n   - Test under load\n   - Monitor database connections\n\n## Deliverables\n- [ ] SchoolContextFactory removed\n- [ ] DbContext registered in DI container\n- [ ] All controllers use injected DbContext\n- [ ] All services use injected DbContext\n- [ ] DbContext lifetime is scoped\n- [ ] Connection resiliency configured\n- [ ] All database operations tested\n- [ ] Performance verified\n\n## Acceptance Criteria\n- No SchoolContextFactory class exists\n- All DbContext usage is through dependency injection\n- DbContext is properly scoped (per request)\n- No connection leaks detected\n- Connection pooling works correctly\n- Retry logic functions properly\n- All CRUD operations work\n- Performance is acceptable\n\n## Estimated Effort\n1 day\n\n## Notes\n- DbContext should be scoped, not singleton\n- DI container handles DbContext disposal automatically\n- Enable retry on failure for production resilience\n- Use connection pooling for better performance\n- Monitor connection count in SQL Server\n- Test with realistic concurrent load\n- Document DbContext configuration decisions\n- Consider using IDbContextFactory<T> for background services if needed\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/11-update-dbcontext-di.md",
    "phase": "phase-1-foundation",
    "task_number": 11
  },
  {
    "title": "Create and Apply EF Core Migrations",
    "body": "# Task: Create and Apply EF Core Migrations\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 4)\n\n## Description\nReplace the DbInitializer pattern with EF Core Migrations for safe database schema management in production.\n\n## Objectives\n- Create initial EF Core migration\n- Replace DbInitializer with migrations\n- Test migration on development database\n- Document migration process\n- Prepare for production database migration\n\n## Prerequisites\n- EF Core 9 configured\n- DbContext properly set up\n- Database schema understood\n- Connection to development database\n\n## Dependencies\n- Phase 1: Task 11 - Update DbContext for Dependency Injection and Remove Static Factory\n\n## Tasks\n1. **Prepare for Migrations:**\n   - Ensure EF Core Tools are installed\n   - Verify DbContext configuration\n   - Back up current database\n   - Document current schema\n\n2. **Create Initial Migration:**\n   ```bash\n   dotnet ef migrations add InitialCreate\n   ```\n   - Review generated migration code\n   - Verify Up() method captures all entities\n   - Verify Down() method for rollback\n   - Check for any issues or warnings\n\n3. **Review Migration Code:**\n   - Check table definitions\n   - Verify indexes\n   - Check foreign keys\n   - Verify data types\n   - Review constraints\n\n4. **Test Migration Locally:**\n   ```bash\n   dotnet ef database update\n   ```\n   - Apply migration to development database\n   - Verify all tables created\n   - Verify relationships are correct\n   - Test application with migrated database\n\n5. **Update DbInitializer:**\n   - Keep seed data logic\n   - Remove database recreation logic\n   - Convert to a seeding strategy\n   - Apply seed data after migration\n   ```csharp\n   public static class DbInitializer\n   {\n       public static async Task SeedAsync(SchoolContext context)\n       {\n           if (await context.Students.AnyAsync())\n               return; // DB has been seeded\n               \n           // Add seed data\n           await context.SaveChangesAsync();\n       }\n   }\n   ```\n\n6. **Update Program.cs:**\n   - Apply migrations on startup (development only)\n   - Run seed data\n   - Handle migration errors gracefully\n   ```csharp\n   using (var scope = app.Services.CreateScope())\n   {\n       var context = scope.ServiceProvider.GetRequiredService<SchoolContext>();\n       \n       if (app.Environment.IsDevelopment())\n       {\n           await context.Database.MigrateAsync(); // Apply pending migrations\n           await DbInitializer.SeedAsync(context);\n       }\n   }\n   ```\n\n7. **Test Migration Workflow:**\n   - Test creating new migration\n   - Test applying migration\n   - Test rolling back migration\n   - Test updating from previous migration\n\n8. **Document Migration Process:**\n   - Document how to create migrations\n   - Document how to apply migrations\n   - Document how to rollback migrations\n   - Create runbook for production migrations\n   - Document troubleshooting steps\n\n9. **Production Migration Strategy:**\n   - Plan production migration approach\n   - Decide on manual vs automatic migrations\n   - Create backup strategy\n   - Plan rollback procedure\n   - Document production migration steps\n\n## Deliverables\n- [ ] Initial EF Core migration created\n- [ ] Migration tested on development database\n- [ ] DbInitializer updated to seed data only\n- [ ] Program.cs configured to apply migrations in development\n- [ ] Migration process documented\n- [ ] Production migration strategy documented\n- [ ] Rollback procedure documented\n- [ ] All database operations work with migrations\n\n## Acceptance Criteria\n- Migration creates correct database schema\n- All tables, indexes, and relationships are correct\n- Seed data works correctly\n- Can create new migrations successfully\n- Can apply and rollback migrations\n- Documentation is clear and complete\n- Production migration plan is ready\n- No data loss during migration\n\n## Estimated Effort\n1 day\n\n## Notes\n- Always back up database before migration\n- Test migrations on non-production data first\n- Keep migrations small and focused\n- Use meaningful migration names\n- Never modify applied migrations\n- Consider zero-downtime deployment strategies\n- Document any manual steps needed for production\n- Test rollback procedure thoroughly\n- Consider using migration bundles for production deployment\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-1-foundation/12-create-migrations.md",
    "phase": "phase-1-foundation",
    "task_number": 12
  },
  {
    "title": "Convert Synchronous Operations to Async/Await",
    "body": "# Task: Convert Synchronous Operations to Async/Await\n\n## Phase\nPhase 1: Foundation - Core Migration (Week 4)\n\n## Description\nConvert all synchronous database operations and I/O operations to use async/await patterns for better scalability and performance.\n\n## Objectives\n- Identify all synchronous operations\n- Convert controller actions to async\n- Convert database queries to async\n- Update views and calling code\n- Test async operations\n- Verify performance improvements\n\n## Prerequisites\n- Controllers migrated to ASP.NET Core\n- DbContext configured\n- Understanding of async/await patterns\n\n## Dependencies\n- Phase 1: Task 12 - Create and Apply EF Core Migrations\n\n## Tasks\n1. **Identify Synchronous Operations:**\n   - Find all database operations (ToList, FirstOrDefault, etc.)\n   - Identify file I/O operations\n   - Find HTTP client calls\n   - Document all synchronous methods\n\n2. **Update Controller Actions:**\n   - Change return type to Task<IActionResult>\n   - Add async keyword to method signature\n   - Update all database calls to async versions\n   ```csharp\n   // Before\n   public IActionResult Index()\n   {\n       var students = _context.Students.ToList();\n       return View(students);\n   }\n   \n   // After\n   public async Task<IActionResult> Index()\n   {\n       var students = await _context.Students.ToListAsync();\n       return View(students);\n   }\n   ```\n\n3. **Convert Database Queries:**\n   - Replace ToList() with ToListAsync()\n   - Replace FirstOrDefault() with FirstOrDefaultAsync()\n   - Replace Any() with AnyAsync()\n   - Replace Count() with CountAsync()\n   - Replace Single() with SingleAsync()\n   - Add await to all async calls\n\n4. **Update Create Operations:**\n   - Replace Add() + SaveChanges() with async version\n   ```csharp\n   _context.Students.Add(student);\n   await _context.SaveChangesAsync();\n   ```\n\n5. **Update Update Operations:**\n   - Replace Update() + SaveChanges() with async version\n   ```csharp\n   _context.Update(student);\n   await _context.SaveChangesAsync();\n   ```\n\n6. **Update Delete Operations:**\n   - Replace Remove() + SaveChanges() with async version\n   ```csharp\n   _context.Students.Remove(student);\n   await _context.SaveChangesAsync();\n   ```\n\n7. **Update File Operations:**\n   - Convert file uploads to async (Phase 2)\n   - Use async file stream operations\n   - Update any file reading operations\n\n8. **Update Service Methods:**\n   - Convert NotificationService methods to async\n   - Update any other service methods\n   - Ensure proper async propagation\n\n9. **Test Async Operations:**\n   - Test each controller action\n   - Verify data is loaded correctly\n   - Check for deadlocks or threading issues\n   - Test error handling\n\n10. **Performance Testing:**\n    - Compare performance before/after\n    - Test under concurrent load\n    - Verify thread pool usage\n    - Monitor resource consumption\n\n11. **Update Error Handling:**\n    - Ensure exceptions in async methods are handled\n    - Use try-catch in async methods\n    - Test error scenarios\n\n## Deliverables\n- [ ] All controller actions are async\n- [ ] All database operations use async methods\n- [ ] All I/O operations are async\n- [ ] Services use async patterns\n- [ ] Error handling works correctly\n- [ ] Performance improvements documented\n- [ ] No deadlocks or threading issues\n\n## Acceptance Criteria\n- All controller actions have async keyword\n- All database calls use async methods\n- No synchronous blocking calls remain\n- Application compiles without warnings\n- All functionality works correctly\n- Performance is improved under load\n- No threading issues detected\n- Error handling works properly\n\n## Estimated Effort\n2-3 days\n\n## Notes\n- Use async/await all the way up the call stack\n- Don't use .Result or .Wait() - these cause deadlocks\n- Use ConfigureAwait(false) in library code, not in ASP.NET Core\n- Async is about scalability, not necessarily speed\n- Test thoroughly under concurrent load\n- Watch for async over sync anti-patterns\n- Use async methods from EF Core, not sync versions\n- Document any remaining synchronous operations and why\n",
    "labels": [
      "phase-1",
      "migration",
      "high",
      "2-3-days"
    ],
    "file_path": "tasks/phase-1-foundation/13-convert-to-async.md",
    "phase": "phase-1-foundation",
    "task_number": 13
  },
  {
    "title": "Export Schema and Data from LocalDB",
    "body": "# Task: Export Schema and Data from LocalDB\n\n## Phase\nPhase 2: Azure Services Integration (Week 1)\n\n## Description\nExport the database schema and data from LocalDB in preparation for migration to Azure SQL Database.\n\n## Objectives\n- Export complete database schema\n- Export all data with referential integrity\n- Validate exported data\n- Create backup scripts\n- Document export process\n\n## Prerequisites\n- Phase 1 completed (application functional on .NET 9)\n- EF Core migrations created\n- Access to LocalDB instance\n- SQL Server Management Studio or Azure Data Studio\n\n## Dependencies\n- Phase 1: Task 12 - Create and Apply EF Core Migrations\n\n## Tasks\n1. **Prepare for Export:**\n   - Back up current LocalDB database\n   - Document database schema\n   - Identify data dependencies\n   - Plan export strategy\n\n2. **Export Using EF Core Migrations:**\n   - Generate migration script\n   ```bash\n   dotnet ef migrations script -o migration.sql\n   ```\n   - Review generated SQL script\n   - Verify all tables and relationships\n   - Save script for deployment\n\n3. **Alternative: Export Using SQL Server Tools:**\n   - Use SSMS to generate scripts\n   - Include schema and data\n   - Configure script options\n   - Export to SQL files\n\n4. **Export Data:**\n   - Use BCP or SSMS to export data\n   - Export in correct dependency order\n   - Include all referential constraints\n   - Verify data completeness\n\n5. **Create Seed Data Script:**\n   - Export sample/test data\n   - Create INSERT statements\n   - Maintain referential integrity\n   - Test script locally\n\n6. **Validate Export:**\n   - Verify all tables included\n   - Check all data exported\n   - Verify foreign key relationships\n   - Check for any missing objects\n\n7. **Create Rollback Script:**\n   - Create script to rollback migration\n   - Test rollback on copy of database\n   - Document rollback procedure\n\n8. **Document Export Process:**\n   - Document steps taken\n   - Note any issues encountered\n   - Create checklist for production export\n   - Document data volumes\n\n## Deliverables\n- [ ] Database schema export script\n- [ ] Data export completed\n- [ ] EF Core migration script generated\n- [ ] Seed data script created\n- [ ] Export validated\n- [ ] Rollback script created\n- [ ] Export process documented\n- [ ] Backup of LocalDB created\n\n## Acceptance Criteria\n- Complete schema exported successfully\n- All data exported with integrity\n- Migration script runs without errors\n- Seed data script works correctly\n- Export is complete and validated\n- Documentation is clear\n- Rollback procedure tested\n\n## Estimated Effort\n1 day\n\n## Notes\n- Always create backups before export\n- Test exported scripts on fresh database\n- Verify row counts match source\n- Handle IDENTITY columns correctly\n- Export in dependency order for foreign keys\n- Consider data size and compression\n- Document any transformations needed\n- Test import on local SQL Server first\n",
    "labels": [
      "phase-2",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/01-export-database.md",
    "phase": "phase-2-azure-integration",
    "task_number": 1
  },
  {
    "title": "Create Azure SQL Database",
    "body": "# Task: Create Azure SQL Database\n\n## Phase\nPhase 2: Azure Services Integration (Week 1)\n\n## Description\nCreate and configure Azure SQL Database for the development environment with proper sizing, security, and configuration.\n\n## Objectives\n- Create Azure SQL Database server and database\n- Configure firewall rules and networking\n- Set up authentication and access control\n- Configure backup and recovery\n- Test connectivity\n\n## Prerequisites\n- Azure subscription configured\n- Database schema exported\n- Resource groups created\n- Understanding of database requirements\n\n## Dependencies\n- Phase 0: Task 04 - Create Azure Resources (partial - may need SQL-specific setup)\n- Phase 2: Task 01 - Export Schema and Data from LocalDB\n\n## Tasks\n1. **Create SQL Database Server:**\n   - Create logical SQL Server in Azure\n   - Choose appropriate region\n   - Configure server admin credentials\n   - Use naming convention (e.g., sql-contoso-university-dev)\n   - Store credentials in Key Vault\n\n2. **Create SQL Database:**\n   - Create database with Serverless tier\n   - Choose vCore model (1 vCore for dev)\n   - Configure auto-pause delay (1 hour)\n   - Set minimum and maximum vCores\n   - Configure storage (5-10 GB for dev)\n\n3. **Configure Firewall Rules:**\n   - Add \"Allow Azure services and resources to access this server\"\n   - Add IP addresses for development machines\n   - Add IP ranges for office/VPN if needed\n   - Document firewall rules\n\n4. **Configure Advanced Security:**\n   - Enable Advanced Data Security (if needed)\n   - Configure threat detection\n   - Enable auditing (optional for dev)\n   - Configure data classification\n\n5. **Configure Backup and Recovery:**\n   - Verify automatic backup is enabled (default)\n   - Configure backup retention (7 days for dev)\n   - Document point-in-time restore capability\n   - Test backup/restore process\n\n6. **Configure Connection Resiliency:**\n   - Enable connection retry logic (already in code)\n   - Configure connection pooling settings\n   - Set command timeout appropriately\n   - Document connection string format\n\n7. **Test Connectivity:**\n   - Test connection from Azure Portal query editor\n   - Test connection from SSMS/Azure Data Studio\n   - Test connection from application\n   - Verify firewall rules work\n\n8. **Configure Monitoring:**\n   - Enable diagnostic logs\n   - Configure log retention\n   - Set up basic alerts (DTU usage, storage)\n   - Create dashboard for monitoring\n\n9. **Document Configuration:**\n   - Document server and database settings\n   - Document connection string format\n   - Document security configuration\n   - Create troubleshooting guide\n\n## Deliverables\n- [ ] Azure SQL Server created\n- [ ] Azure SQL Database created (Serverless tier)\n- [ ] Firewall rules configured\n- [ ] Advanced security configured\n- [ ] Backup and recovery verified\n- [ ] Connectivity tested from multiple sources\n- [ ] Monitoring and alerts configured\n- [ ] Configuration documented\n- [ ] Connection string stored in Key Vault\n\n## Acceptance Criteria\n- SQL Server and database are accessible\n- Can connect from development machines\n- Can connect from Azure services\n- Firewall rules allow required access\n- Backup is configured correctly\n- Monitoring is capturing metrics\n- Connection string is secured in Key Vault\n- Documentation is complete\n\n## Estimated Effort\n1 day\n\n## Notes\n- Use Serverless tier for development to minimize costs\n- Database auto-pauses after 1 hour of inactivity\n- First request after auto-pause may be slow (resume time)\n- Use locally redundant storage for dev (cheaper)\n- Consider geo-redundancy for production\n- Set up cost alerts to avoid surprises\n- Test connection from different networks\n- Document any connection troubleshooting steps\n- Use managed identity for production (setup in later task)\n",
    "labels": [
      "phase-2",
      "azure",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/02-create-azure-sql.md",
    "phase": "phase-2-azure-integration",
    "task_number": 2
  },
  {
    "title": "Run Database Migrations on Azure SQL",
    "body": "# Task: Run Database Migrations on Azure SQL\n\n## Phase\nPhase 2: Azure Services Integration (Week 1)\n\n## Description\nApply EF Core migrations to Azure SQL Database and import seed data for development and testing.\n\n## Objectives\n- Apply EF Core migrations to Azure SQL\n- Import seed data\n- Verify database schema\n- Test database operations\n- Document migration process\n\n## Prerequisites\n- Azure SQL Database created\n- EF Core migrations ready\n- Database export scripts ready\n- Connection string available\n\n## Dependencies\n- Phase 2: Task 02 - Create Azure SQL Database\n\n## Tasks\n1. **Update Connection String:**\n   - Get Azure SQL connection string from portal\n   - Add to appsettings.Development.json\n   - Store in user secrets locally\n   - Verify connection string format\n   ```json\n   {\n     \"ConnectionStrings\": {\n       \"DefaultConnection\": \"Server=tcp:sql-contoso-dev.database.windows.net,1433;Initial Catalog=ContosoUniversity;...\"\n     }\n   }\n   ```\n\n2. **Test Connection:**\n   - Test connection from application\n   - Verify firewall allows connection\n   - Test with SQL Server Management Studio\n   - Resolve any connection issues\n\n3. **Apply Migrations Using EF Core:**\n   - Run migration command\n   ```bash\n   dotnet ef database update --connection \"connection_string\"\n   ```\n   - Verify migration applied successfully\n   - Check for errors in output\n   - Verify all tables created\n\n4. **Alternative: Apply Migration Script:**\n   - Run generated migration.sql script\n   - Execute using SSMS or Azure Data Studio\n   - Verify execution completed\n   - Check for errors\n\n5. **Verify Schema:**\n   - Connect to Azure SQL with SSMS\n   - Verify all tables exist\n   - Check indexes and constraints\n   - Verify foreign key relationships\n   - Check column types and nullability\n\n6. **Import Seed Data:**\n   - Run DbInitializer seed logic\n   - Or execute seed data SQL script\n   - Verify data imported correctly\n   - Check referential integrity\n\n7. **Verify Data:**\n   - Query tables to verify data\n   - Check row counts\n   - Verify relationships between tables\n   - Test sample queries\n\n8. **Update Application Configuration:**\n   - Update connection string in application\n   - Test application with Azure SQL\n   - Verify CRUD operations work\n   - Test all major features\n\n9. **Configure Migration Automation:**\n   - Update Program.cs to apply migrations on startup (dev only)\n   - Test automatic migration application\n   - Document manual migration process for production\n\n10. **Test Database Operations:**\n    - Test Create operations\n    - Test Read operations\n    - Test Update operations\n    - Test Delete operations\n    - Test complex queries with joins\n    - Test pagination and sorting\n\n11. **Performance Testing:**\n    - Compare performance with LocalDB\n    - Test query response times\n    - Monitor DTU usage\n    - Identify slow queries\n\n## Deliverables\n- [ ] Connection string configured\n- [ ] Migrations applied to Azure SQL\n- [ ] Database schema verified\n- [ ] Seed data imported\n- [ ] Application connected to Azure SQL\n- [ ] All CRUD operations tested\n- [ ] Performance benchmarks documented\n- [ ] Migration process documented\n\n## Acceptance Criteria\n- Database schema matches local database\n- All migrations applied successfully\n- Seed data imported correctly\n- Application connects to Azure SQL\n- All database operations work\n- Performance is acceptable\n- No errors in application logs\n- Documentation is complete\n\n## Estimated Effort\n1 day\n\n## Notes\n- Always back up before running migrations\n- Test migrations on dev database first\n- Monitor DTU usage during testing\n- Keep LocalDB as backup during transition\n- Document any performance issues\n- Plan for production migration separately\n- Use connection resiliency in application\n- Test error scenarios (connection failures, timeouts)\n- Consider using migration bundles for production\n",
    "labels": [
      "phase-2",
      "azure",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/03-run-migrations-azure.md",
    "phase": "phase-2-azure-integration",
    "task_number": 3
  },
  {
    "title": "Update Connection String and Test Connectivity",
    "body": "# Task: Update Connection String and Test Connectivity\n\n## Phase\nPhase 2: Azure Services Integration (Week 1)\n\n## Description\nUpdate the application to use Azure SQL Database connection string and implement robust connection handling with retry logic.\n\n## Objectives\n- Configure Azure SQL connection string\n- Implement connection resiliency\n- Test connection under various scenarios\n- Configure connection pooling\n- Handle connection failures gracefully\n\n## Prerequisites\n- Azure SQL Database configured and migrations applied\n- Application code updated to .NET 9\n- Understanding of connection resiliency patterns\n\n## Dependencies\n- Phase 2: Task 03 - Run Database Migrations on Azure SQL\n\n## Tasks\n1. **Update Connection String Configuration:**\n   - Add Azure SQL connection string to appsettings.Development.json\n   - Use user secrets for local development\n   - Document connection string format\n   - Verify Encrypt=True for security\n\n2. **Configure Connection Resiliency:**\n   - Already configured in DbContext registration, verify:\n   ```csharp\n   builder.Services.AddDbContext<SchoolContext>(options =>\n       options.UseSqlServer(\n           builder.Configuration.GetConnectionString(\"DefaultConnection\"),\n           sqlOptions => \n           {\n               sqlOptions.EnableRetryOnFailure(\n                   maxRetryCount: 5,\n                   maxRetryDelay: TimeSpan.FromSeconds(30),\n                   errorNumbersToAdd: null);\n               sqlOptions.CommandTimeout(30);\n           }\n       )\n   );\n   ```\n\n3. **Configure Connection Pooling:**\n   - Verify connection string has pooling enabled (default)\n   - Set Min Pool Size if needed\n   - Set Max Pool Size appropriately\n   - Document pooling settings\n\n4. **Test Basic Connectivity:**\n   - Start application\n   - Verify connection succeeds\n   - Test database operations\n   - Check application logs for errors\n\n5. **Test Connection Resiliency:**\n   - Simulate transient failures\n   - Verify retry logic works\n   - Test timeout scenarios\n   - Verify error handling\n\n6. **Test Connection Pooling:**\n   - Test concurrent requests\n   - Monitor connection count in Azure\n   - Verify connections are reused\n   - Check for connection leaks\n\n7. **Test Firewall Scenarios:**\n   - Test from different networks\n   - Verify firewall rules work\n   - Test VPN connectivity if applicable\n   - Document any connectivity issues\n\n8. **Implement Health Checks:**\n   - Add health check for database connectivity\n   ```csharp\n   builder.Services.AddHealthChecks()\n       .AddDbContextCheck<SchoolContext>();\n   \n   app.MapHealthChecks(\"/health\");\n   ```\n   - Test health check endpoint\n   - Verify health check fails when database is down\n\n9. **Configure Error Handling:**\n   - Handle connection failures gracefully\n   - Show user-friendly error messages\n   - Log connection errors\n   - Implement circuit breaker if needed\n\n10. **Update Development Workflow:**\n    - Document how to switch between LocalDB and Azure SQL\n    - Update README with connection setup\n    - Create troubleshooting guide\n    - Document firewall configuration steps\n\n11. **Performance Testing:**\n    - Compare latency with LocalDB\n    - Test query performance\n    - Monitor DTU usage\n    - Identify any bottlenecks\n\n12. **Security Review:**\n    - Verify connection string is not in source control\n    - Verify encryption is enabled (Encrypt=True)\n    - Check certificate validation\n    - Review authentication method\n\n## Deliverables\n- [ ] Azure SQL connection string configured\n- [ ] Connection resiliency implemented\n- [ ] Connection pooling configured\n- [ ] Health checks implemented\n- [ ] Connectivity tested from all environments\n- [ ] Error handling implemented\n- [ ] Performance benchmarks documented\n- [ ] Troubleshooting guide created\n\n## Acceptance Criteria\n- Application connects to Azure SQL successfully\n- Retry logic handles transient failures\n- Connection pooling works correctly\n- Health check endpoint responds correctly\n- No connection leaks detected\n- Error messages are user-friendly\n- Performance is acceptable\n- Documentation is complete\n\n## Estimated Effort\n1 day\n\n## Notes\n- Use Encrypt=True in connection string for security\n- Enable retry logic for production resilience\n- Monitor connection count in Azure portal\n- Set appropriate timeout values (not too high)\n- Test from different network locations\n- Keep LocalDB setup for offline development\n- Use Azure AD authentication for production (later task)\n- Document any network-specific issues\n- Consider using connection string builder for clarity\n",
    "labels": [
      "phase-2",
      "testing",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/04-test-connectivity.md",
    "phase": "phase-2-azure-integration",
    "task_number": 4
  },
  {
    "title": "Create Azure Service Bus Namespace and Queue",
    "body": "# Task: Create Azure Service Bus Namespace and Queue\n\n## Phase\nPhase 2: Azure Services Integration (Week 2)\n\n## Description\nCreate and configure Azure Service Bus namespace and queue to replace MSMQ for notification messaging.\n\n## Objectives\n- Create Azure Service Bus namespace\n- Create queue for notifications\n- Configure queue properties\n- Set up access policies\n- Test message sending and receiving\n\n## Prerequisites\n- Azure subscription and resource groups configured\n- Understanding of current MSMQ implementation\n- NotificationService code reviewed\n\n## Dependencies\n- Phase 2: Task 04 - Update Connection String and Test Connectivity\n\n## Tasks\n1. **Create Service Bus Namespace:**\n   - Create namespace in Azure portal or CLI\n   - Choose Standard tier (supports queues and topics)\n   - Select appropriate region (same as other resources)\n   - Use naming convention (e.g., sbns-contoso-university-dev)\n   - Document configuration\n\n2. **Configure Namespace Settings:**\n   - Configure messaging units if Premium (not needed for Standard)\n   - Enable zone redundancy (optional for dev)\n   - Configure diagnostic logs\n   - Set up monitoring\n\n3. **Create Queue:**\n   - Create queue named \"notifications\"\n   - Configure queue properties:\n     - Max size: 1 GB (dev)\n     - Message TTL: 14 days\n     - Lock duration: 30 seconds\n     - Max delivery count: 10\n     - Enable dead-letter queue\n     - Enable duplicate detection (5-minute window)\n   - Document queue configuration\n\n4. **Configure Access Policies:**\n   - Create policy with Send and Listen permissions\n   - Name: \"SendListenPolicy\"\n   - Generate connection string\n   - Store connection string in Key Vault\n\n5. **Test Queue in Portal:**\n   - Use Service Bus Explorer in portal\n   - Send test message\n   - Receive test message\n   - Verify message delivery\n   - Test dead-letter queue\n\n6. **Configure Monitoring:**\n   - Enable diagnostic logs\n   - Configure metrics collection\n   - Set up basic alerts:\n     - Dead-letter message count\n     - Active message count\n     - Failed requests\n   - Create monitoring dashboard\n\n7. **Configure Dead-Letter Queue:**\n   - Verify dead-letter queue is enabled\n   - Document dead-letter handling strategy\n   - Plan for monitoring dead-letter messages\n\n8. **Security Configuration:**\n   - Review access policies\n   - Consider using Managed Identity (Phase 2, later task)\n   - Verify network access\n   - Document security settings\n\n9. **Performance Configuration:**\n   - Configure batch processing settings\n   - Set appropriate prefetch count\n   - Document performance settings\n   - Plan for scaling if needed\n\n10. **Document Configuration:**\n    - Document namespace and queue settings\n    - Document connection string format\n    - Create troubleshooting guide\n    - Document monitoring and alerts\n\n## Deliverables\n- [ ] Service Bus namespace created\n- [ ] Queue created with proper configuration\n- [ ] Access policies configured\n- [ ] Connection string stored in Key Vault\n- [ ] Test messages sent and received\n- [ ] Monitoring and alerts configured\n- [ ] Dead-letter queue configured\n- [ ] Configuration documented\n\n## Acceptance Criteria\n- Service Bus namespace is accessible\n- Queue is created with correct properties\n- Can send and receive messages via portal\n- Connection string is secured\n- Monitoring is capturing metrics\n- Alerts are configured\n- Documentation is complete\n- Dead-letter queue handling is defined\n\n## Estimated Effort\n1 day\n\n## Notes\n- Standard tier is sufficient for most scenarios\n- Premium tier offers better performance and isolation\n- Use duplicate detection to prevent duplicate notifications\n- Monitor dead-letter queue regularly\n- Set appropriate TTL to prevent message accumulation\n- Consider using topics if multiple subscribers needed\n- Test failover and recovery scenarios\n- Document any network requirements\n- Plan for production queue sizing separately\n",
    "labels": [
      "phase-2",
      "azure",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/05-create-service-bus.md",
    "phase": "phase-2-azure-integration",
    "task_number": 5
  },
  {
    "title": "Update NotificationService to Use Azure Service Bus",
    "body": "# Task: Update NotificationService to Use Azure Service Bus\n\n## Phase\nPhase 2: Azure Services Integration (Week 2)\n\n## Description\nReplace the MSMQ-based NotificationService implementation with Azure Service Bus for cross-platform messaging.\n\n## Objectives\n- Remove System.Messaging dependencies\n- Implement Azure Service Bus message sending\n- Implement message receiving/polling\n- Update error handling and retry logic\n- Test notification functionality\n\n## Prerequisites\n- Azure Service Bus namespace and queue created\n- Connection string available\n- NotificationService interface defined\n- Understanding of current notification flow\n\n## Dependencies\n- Phase 2: Task 05 - Create Azure Service Bus Namespace and Queue\n\n## Tasks\n1. **Add Azure Service Bus Package:**\n   ```bash\n   dotnet add package Azure.Messaging.ServiceBus\n   ```\n\n2. **Remove MSMQ Dependencies:**\n   - Remove System.Messaging references\n   - Remove MessageQueue code\n   - Remove MSMQ-specific configuration\n   - Document removed functionality\n\n3. **Create Service Bus Configuration:**\n   - Add configuration section to appsettings.json\n   ```json\n   {\n     \"ServiceBus\": {\n       \"ConnectionString\": \"from-key-vault\",\n       \"QueueName\": \"notifications\"\n     }\n   }\n   ```\n   - Create strongly-typed configuration class\n   - Register configuration in DI\n\n4. **Update INotificationService Interface:**\n   ```csharp\n   public interface INotificationService\n   {\n       Task SendNotificationAsync(string entityType, string action, int entityId, string details);\n       Task<List<Notification>> GetRecentNotificationsAsync(int count = 5);\n   }\n   ```\n\n5. **Implement Send Message Functionality:**\n   ```csharp\n   public class ServiceBusNotificationService : INotificationService\n   {\n       private readonly ServiceBusClient _client;\n       private readonly ServiceBusSender _sender;\n       \n       public ServiceBusNotificationService(IOptions<ServiceBusOptions> options)\n       {\n           _client = new ServiceBusClient(options.Value.ConnectionString);\n           _sender = _client.CreateSender(options.Value.QueueName);\n       }\n       \n       public async Task SendNotificationAsync(string entityType, string action, \n           int entityId, string details)\n       {\n           var notification = new Notification\n           {\n               EntityType = entityType,\n               Action = action,\n               EntityId = entityId,\n               Details = details,\n               Timestamp = DateTime.UtcNow\n           };\n           \n           var message = new ServiceBusMessage(JsonSerializer.Serialize(notification))\n           {\n               MessageId = Guid.NewGuid().ToString(),\n               ContentType = \"application/json\"\n           };\n           \n           await _sender.SendMessageAsync(message);\n       }\n   }\n   ```\n\n6. **Implement Error Handling:**\n   - Add try-catch blocks\n   - Log errors appropriately\n   - Implement retry logic\n   - Don't fail user operations if notification fails\n   ```csharp\n   try\n   {\n       await SendNotificationAsync(...);\n   }\n   catch (Exception ex)\n   {\n       _logger.LogError(ex, \"Failed to send notification\");\n       // Don't throw - notification is not critical\n   }\n   ```\n\n7. **Implement Message Receiving:**\n   - Create background service or API endpoint\n   - Use ServiceBusReceiver to poll for messages\n   - Process messages and store in database if needed\n   - Complete/abandon messages appropriately\n   ```csharp\n   var receiver = _client.CreateReceiver(queueName);\n   var message = await receiver.ReceiveMessageAsync(timeout);\n   if (message != null)\n   {\n       // Process message\n       await receiver.CompleteMessageAsync(message);\n   }\n   ```\n\n8. **Update Controllers:**\n   - Verify controllers use INotificationService\n   - Test notification sending from CRUD operations\n   - Verify async patterns are used\n   - Test error handling\n\n9. **Update NotificationsController:**\n   - Update GetRecentNotifications to read from Service Bus or database\n   - Implement proper API endpoints\n   - Add error handling\n   - Test API responses\n\n10. **Register Service in DI:**\n    ```csharp\n    builder.Services.Configure<ServiceBusOptions>(\n        builder.Configuration.GetSection(\"ServiceBus\"));\n    builder.Services.AddSingleton<INotificationService, ServiceBusNotificationService>();\n    ```\n\n11. **Test Notification Flow:**\n    - Create a student, verify notification sent\n    - Update a course, verify notification sent\n    - Delete an instructor, verify notification sent\n    - Verify messages appear in Azure portal\n    - Test error scenarios\n\n12. **Cleanup:**\n    - Remove all MSMQ code\n    - Remove MSMQ configuration\n    - Update documentation\n    - Remove System.Messaging package\n\n## Deliverables\n- [ ] Azure.Messaging.ServiceBus package added\n- [ ] System.Messaging references removed\n- [ ] ServiceBusNotificationService implemented\n- [ ] Send functionality working\n- [ ] Receive functionality working\n- [ ] Error handling implemented\n- [ ] All CRUD operations send notifications\n- [ ] Service registered in DI\n- [ ] Tests passed\n- [ ] MSMQ code removed\n\n## Acceptance Criteria\n- Notifications are sent to Azure Service Bus\n- Messages can be received and processed\n- No System.Messaging references remain\n- Error handling works gracefully\n- Notifications don't block user operations\n- All tests pass\n- Code is well-documented\n- MSMQ dependencies completely removed\n\n## Estimated Effort\n2-3 days\n\n## Notes\n- Make notification sending non-blocking (fire and forget with error logging)\n- Use async/await throughout\n- Consider using IHostedService for background message processing\n- Test with Service Bus Explorer during development\n- Monitor dead-letter queue for failed messages\n- Consider adding message batching for performance\n- Document message format and schema\n- Plan for future SignalR integration (real-time UI updates)\n",
    "labels": [
      "phase-2",
      "azure",
      "high",
      "2-3-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/06-update-notification-service.md",
    "phase": "phase-2-azure-integration",
    "task_number": 6
  },
  {
    "title": "Create Azure Blob Storage Account and Container",
    "body": "# Task: Create Azure Blob Storage Account and Container\n\n## Phase\nPhase 2: Azure Services Integration (Week 2)\n\n## Description\nCreate Azure Blob Storage account and container to replace local file system for teaching material uploads.\n\n## Objectives\n- Create Azure Storage account\n- Create blob container for teaching materials\n- Configure access and security\n- Test blob operations\n- Set up monitoring\n\n## Prerequisites\n- Azure subscription and resource groups configured\n- Understanding of current file upload implementation\n- File upload paths documented\n\n## Dependencies\n- Phase 2: Task 06 - Update NotificationService to Use Azure Service Bus\n\n## Tasks\n1. **Create Storage Account:**\n   - Create storage account in Azure portal or CLI\n   - Choose Standard performance tier\n   - Choose Locally Redundant Storage (LRS) for dev\n   - Use naming convention (e.g., stcontosounivdev)\n   - Select same region as other resources\n   - Enable soft delete (optional for dev)\n\n2. **Configure Storage Account Settings:**\n   - Enable blob versioning (optional)\n   - Configure firewall and virtual networks\n   - Enable secure transfer required (HTTPS)\n   - Configure minimum TLS version (1.2)\n   - Document configuration\n\n3. **Create Blob Container:**\n   - Create container named \"teaching-materials\"\n   - Set access level to Private (blob)\n   - Configure metadata if needed\n   - Document container settings\n\n4. **Configure CORS (if needed):**\n   - Add CORS rules for web access\n   - Configure allowed origins\n   - Configure allowed methods (GET, POST, PUT, DELETE)\n   - Configure allowed headers\n   - Test CORS configuration\n\n5. **Set Up Access Keys:**\n   - Generate access keys\n   - Store connection string in Key Vault\n   - Document key rotation policy\n   - Plan for using Managed Identity later\n\n6. **Configure SAS Tokens:**\n   - Understand SAS token creation\n   - Document SAS token usage for secure file access\n   - Plan SAS token expiration strategy\n   - Test SAS token generation\n\n7. **Test Blob Operations:**\n   - Use Azure Storage Explorer\n   - Upload test file\n   - Download test file\n   - Delete test file\n   - List blobs in container\n\n8. **Configure Lifecycle Management:**\n   - Set up blob lifecycle policies (optional)\n   - Archive old blobs to cool/archive tier\n   - Delete old blobs after retention period\n   - Document lifecycle policy\n\n9. **Configure Monitoring:**\n   - Enable diagnostic logs\n   - Configure metrics collection\n   - Set up alerts for:\n     - Storage capacity\n     - Failed requests\n     - Throttling\n   - Create monitoring dashboard\n\n10. **Configure Backup (optional for dev):**\n    - Enable soft delete\n    - Configure retention period\n    - Document backup strategy\n    - Test restore process\n\n11. **Security Configuration:**\n    - Review access policies\n    - Verify HTTPS is enforced\n    - Plan for managed identity usage\n    - Document security settings\n\n12. **Cost Optimization:**\n    - Review storage tier (Hot for dev)\n    - Configure lifecycle management\n    - Monitor storage usage\n    - Set up cost alerts\n\n## Deliverables\n- [ ] Storage account created\n- [ ] Blob container created\n- [ ] Access configured (private)\n- [ ] Connection string stored in Key Vault\n- [ ] CORS configured if needed\n- [ ] SAS token strategy documented\n- [ ] Monitoring and alerts configured\n- [ ] Test operations completed successfully\n- [ ] Configuration documented\n\n## Acceptance Criteria\n- Storage account is accessible\n- Blob container is created\n- Can upload and download blobs\n- Connection string is secured\n- CORS works if needed\n- Monitoring captures metrics\n- Alerts are configured\n- Documentation is complete\n- Security settings are appropriate\n\n## Estimated Effort\n1 day\n\n## Notes\n- Use Hot tier for frequently accessed files\n- Consider Cool or Archive tier for old files\n- Enable soft delete for accidental deletion protection\n- Use Managed Identity for better security (later task)\n- Test blob operations from Azure Portal\n- Monitor storage costs regularly\n- Plan for CDN integration if global access needed\n- Document naming conventions for blobs\n- Consider using Storage Explorer for testing\n- Plan for production storage sizing separately\n",
    "labels": [
      "phase-2",
      "deployment",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/07-create-blob-storage.md",
    "phase": "phase-2-azure-integration",
    "task_number": 7
  },
  {
    "title": "Update File Upload to Use Azure Blob Storage",
    "body": "# Task: Update File Upload to Use Azure Blob Storage\n\n## Phase\nPhase 2: Azure Services Integration (Week 2)\n\n## Description\nReplace local file system storage with Azure Blob Storage for teaching material uploads.\n\n## Objectives\n- Add Azure.Storage.Blobs SDK\n- Update CoursesController file upload logic\n- Implement blob upload/download methods\n- Generate SAS tokens for secure access\n- Update views to display blob URLs\n- Remove local file system dependencies\n\n## Prerequisites\n- Blob Storage account and container created\n- Connection string available\n- Current file upload code reviewed\n\n## Dependencies\n- Phase 2: Task 07 - Create Azure Blob Storage Account and Container\n\n## Tasks\n1. Add Azure.Storage.Blobs NuGet package\n2. Create BlobStorageService with upload/download/delete methods\n3. Register BlobStorageService in DI container\n4. Update CoursesController Create/Edit actions to use blob storage\n5. Generate SAS tokens for secure file access\n6. Update views to use blob URLs instead of local paths\n7. Implement file deletion when course is deleted or file replaced\n8. Test file upload, download, and deletion\n9. Remove local file system upload code\n10. Update documentation\n\n## Estimated Effort\n2-3 days\n\n## Acceptance Criteria\n- Files upload to Blob Storage successfully\n- Files are accessible via SAS URLs\n- Old files are deleted properly\n- No local file system dependencies remain\n- All tests pass\n",
    "labels": [
      "phase-2",
      "azure",
      "high",
      "2-3-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/08-update-file-upload.md",
    "phase": "phase-2-azure-integration",
    "task_number": 8
  },
  {
    "title": "Set Up Azure AD B2C Tenant",
    "body": "# Task: Set Up Azure AD B2C Tenant\n\n## Phase\nPhase 2: Azure Services Integration (Week 3)\n\n## Description\nSet up Azure AD B2C tenant for modern authentication, replacing Windows Authentication.\n\n## Objectives\n- Create Azure AD B2C tenant\n- Register application\n- Configure user flows\n- Set up authentication policies\n- Test authentication\n\n## Prerequisites\n- Azure subscription available\n- Understanding of authentication requirements\n- Application inventory of users and roles\n\n## Dependencies\n- Phase 2: Task 08 - Update File Upload to Use Azure Blob Storage\n\n## Tasks\n1. Create Azure AD B2C tenant\n2. Register web application in B2C\n3. Configure redirect URIs\n4. Set up sign-up and sign-in user flows\n5. Configure password reset flow\n6. Define custom attributes if needed\n7. Configure branding (optional)\n8. Test authentication flows in Azure portal\n9. Document tenant and application settings\n10. Store B2C configuration values\n\n## Estimated Effort\n1-2 days\n\n## Acceptance Criteria\n- B2C tenant is created\n- Application is registered\n- User flows are configured\n- Can test authentication in portal\n- Configuration is documented\n",
    "labels": [
      "phase-2",
      "azure",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/09-setup-azure-ad-b2c.md",
    "phase": "phase-2-azure-integration",
    "task_number": 9
  },
  {
    "title": "Implement Azure AD B2C Authentication",
    "body": "# Task: Implement Azure AD B2C Authentication\n\n## Phase\nPhase 2: Azure Services Integration (Week 3)\n\n## Description\nImplement Azure AD B2C authentication in the application, replacing Windows Authentication.\n\n## Objectives\n- Add Microsoft.Identity.Web packages\n- Configure authentication middleware\n- Update controllers with [Authorize] attributes\n- Convert role-based to claims-based authorization\n- Test authentication flows\n\n## Prerequisites\n- Azure AD B2C tenant configured\n- Application registered\n- User flows created\n\n## Dependencies\n- Phase 2: Task 09 - Set Up Azure AD B2C Tenant\n\n## Tasks\n1. Add Microsoft.Identity.Web and Microsoft.Identity.Web.UI packages\n2. Configure authentication in Program.cs\n3. Add Azure AD B2C settings to appsettings.json\n4. Configure authentication middleware\n5. Update [Authorize] attributes on controllers\n6. Implement claims-based authorization\n7. Update _Layout.cshtml with sign-in/sign-out links\n8. Test sign-in flow\n9. Test sign-out flow\n10. Test authorized and unauthorized access\n11. Remove Windows Authentication\n12. Document authentication setup\n\n## Estimated Effort\n2-3 days\n\n## Acceptance Criteria\n- Users can sign in with Azure AD B2C\n- Users can sign out\n- Authorized pages require authentication\n- Claims are properly populated\n- Windows Authentication is removed\n- Documentation is complete\n",
    "labels": [
      "phase-2",
      "azure",
      "high",
      "2-3-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/10-implement-authentication.md",
    "phase": "phase-2-azure-integration",
    "task_number": 10
  },
  {
    "title": "Set Up Azure Key Vault and Move Secrets",
    "body": "# Task: Set Up Azure Key Vault and Move Secrets\n\n## Phase\nPhase 2: Azure Services Integration (Week 3)\n\n## Description\nCreate Azure Key Vault and migrate all secrets from configuration files to secure storage.\n\n## Objectives\n- Create Azure Key Vault\n- Store connection strings and secrets\n- Configure application to read from Key Vault\n- Implement Managed Identity (preparation)\n- Remove secrets from appsettings.json\n\n## Prerequisites\n- Azure subscription configured\n- All connection strings documented\n- Understanding of secrets to migrate\n\n## Dependencies\n- Phase 2: Task 10 - Implement Azure AD B2C Authentication\n\n## Tasks\n1. Create Azure Key Vault in Azure portal\n2. Configure access policies for development team\n3. Store secrets in Key Vault:\n   - SQL Database connection string\n   - Service Bus connection string\n   - Storage Account connection string\n   - Azure AD B2C client secret\n4. Add Azure.Extensions.AspNetCore.Configuration.Secrets package\n5. Configure application to read from Key Vault\n6. Test application with Key Vault integration\n7. Remove secrets from appsettings.json (keep keys only)\n8. Update documentation\n9. Plan for Managed Identity setup (Phase 4)\n\n## Estimated Effort\n1-2 days\n\n## Acceptance Criteria\n- Key Vault is created\n- All secrets are stored in Key Vault\n- Application reads secrets from Key Vault\n- No secrets in appsettings.json\n- Application works correctly\n- Documentation is updated\n",
    "labels": [
      "phase-2",
      "azure",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/11-setup-key-vault.md",
    "phase": "phase-2-azure-integration",
    "task_number": 11
  },
  {
    "title": "Test All Azure Services Integration",
    "body": "# Task: Test All Azure Services Integration\n\n## Phase\nPhase 2: Azure Services Integration (Week 3)\n\n## Description\nComprehensive testing of all Azure services integration to ensure everything works together correctly.\n\n## Objectives\n- Test end-to-end scenarios\n- Verify all Azure services integration\n- Test error handling\n- Perform integration testing\n- Document any issues\n\n## Prerequisites\n- All Phase 2 tasks completed\n- Azure SQL, Service Bus, Blob Storage, AD B2C configured\n- Application fully migrated to Azure services\n\n## Dependencies\n- Phase 2: Task 11 - Set Up Azure Key Vault and Move Secrets\n\n## Tasks\n1. **Test Database Operations:**\n   - Test CRUD for all entities\n   - Test complex queries\n   - Test concurrent operations\n   - Verify connection resiliency\n\n2. **Test Notification System:**\n   - Send notifications from various actions\n   - Verify messages in Service Bus\n   - Test message retrieval\n   - Check dead-letter queue handling\n\n3. **Test File Upload:**\n   - Upload teaching materials\n   - Verify files in Blob Storage\n   - Download files using SAS URLs\n   - Delete files and verify removal\n\n4. **Test Authentication:**\n   - Sign in with test users\n   - Test authorized access\n   - Test unauthorized access\n   - Test sign-out\n\n5. **Test Configuration:**\n   - Verify secrets from Key Vault\n   - Test environment-specific settings\n   - Verify all connection strings work\n\n6. **Integration Testing:**\n   - Test complete user workflows\n   - Test error scenarios\n   - Test timeout scenarios\n   - Test network failures\n\n7. **Performance Testing:**\n   - Test response times\n   - Test under load\n   - Monitor Azure resource usage\n   - Identify bottlenecks\n\n8. **Security Testing:**\n   - Verify HTTPS enforcement\n   - Test authentication requirements\n   - Verify secrets are not exposed\n   - Test SAS token expiration\n\n9. **Document Issues:**\n   - Log any bugs found\n   - Document workarounds\n   - Create issue tickets\n   - Prioritize fixes\n\n## Estimated Effort\n2-3 days\n\n## Acceptance Criteria\n- All CRUD operations work\n- Notifications are sent and received\n- File uploads work correctly\n- Authentication works properly\n- All Azure services are functional\n- No critical bugs found\n- Performance is acceptable\n- Documentation is complete\n",
    "labels": [
      "phase-2",
      "testing",
      "high",
      "2-3-days"
    ],
    "file_path": "tasks/phase-2-azure-integration/12-test-integration.md",
    "phase": "phase-2-azure-integration",
    "task_number": 12
  },
  {
    "title": "Set Up Test Projects",
    "body": "# Task: Set Up Test Projects\n\n## Phase\nPhase 3: Testing and Quality (Week 1)\n\n## Description\nCreate comprehensive test project structure with unit, integration, and E2E test projects.\n\n## Objectives\n- Create test project structure\n- Add testing frameworks\n- Set up test data builders\n- Configure test databases\n- Establish testing patterns\n\n## Dependencies\n- Phase 2: Task 12 - Test All Azure Services Integration\n\n## Tasks\n1. Create ContosoUniversity.Tests.Unit project\n2. Create ContosoUniversity.Tests.Integration project\n3. Create ContosoUniversity.Tests.E2E project (optional)\n4. Add xUnit, Moq, FluentAssertions packages\n5. Set up in-memory database for integration tests\n6. Create test data builders and fixtures\n7. Configure test settings\n8. Document testing standards\n\n## Estimated Effort\n1-2 days\n\n## Acceptance Criteria\n- Test projects created\n- Testing frameworks installed\n- Can run empty tests\n- Test infrastructure documented\n",
    "labels": [
      "phase-3",
      "testing",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-3-testing-quality/01-setup-test-projects.md",
    "phase": "phase-3-testing-quality",
    "task_number": 1
  },
  {
    "title": "Write Unit Tests for Controllers and Services",
    "body": "# Task: Write Unit Tests for Controllers and Services\n\n## Phase\nPhase 3: Testing and Quality (Week 1)\n\n## Description\nWrite comprehensive unit tests for controllers and services with 70%+ code coverage target.\n\n## Objectives\n- Write unit tests for all controllers\n- Write unit tests for services\n- Mock dependencies\n- Achieve 70%+ code coverage\n- Document test patterns\n\n## Dependencies\n- Phase 3: Task 01 - Set Up Test Projects\n\n## Tasks\n1. Write tests for StudentsController (CRUD operations)\n2. Write tests for CoursesController (CRUD + file upload)\n3. Write tests for InstructorsController\n4. Write tests for DepartmentsController\n5. Write tests for HomeController\n6. Write tests for NotificationService\n7. Write tests for BlobStorageService\n8. Mock DbContext, Service Bus, Blob Storage\n9. Test error scenarios\n10. Run code coverage analysis\n11. Improve coverage to 70%+\n12. Document test patterns\n\n## Estimated Effort\n3-4 days\n\n## Acceptance Criteria\n- All controllers have unit tests\n- All services have unit tests\n- Code coverage >= 70%\n- All tests pass\n- Tests are well-documented\n",
    "labels": [
      "phase-3",
      "testing",
      "high",
      "3-4-days"
    ],
    "file_path": "tasks/phase-3-testing-quality/02-write-unit-tests.md",
    "phase": "phase-3-testing-quality",
    "task_number": 2
  },
  {
    "title": "Write Integration Tests",
    "body": "# Task: Write Integration Tests\n\n## Phase\nPhase 3: Testing and Quality (Week 1)\n\n## Description\nWrite integration tests for data layer and Azure services integration.\n\n## Objectives\n- Test database operations with real DbContext\n- Test Azure services integration\n- Test complete workflows\n- Verify data integrity\n\n## Dependencies\n- Phase 3: Task 02 - Write Unit Tests for Controllers and Services\n\n## Tasks\n1. Create integration tests for SchoolContext\n2. Test CRUD operations with in-memory database\n3. Test complex queries and relationships\n4. Test EF Core migrations\n5. Test Azure Service Bus integration (if possible)\n6. Test Blob Storage integration (if possible)\n7. Test authentication flows\n8. Run integration tests in CI/CD\n9. Document integration test patterns\n\n## Estimated Effort\n2-3 days\n\n## Acceptance Criteria\n- Integration tests for data layer complete\n- Tests use in-memory database\n- All tests pass\n- Tests run in CI/CD pipeline\n- Documentation complete\n",
    "labels": [
      "phase-3",
      "testing",
      "high",
      "2-3-days"
    ],
    "file_path": "tasks/phase-3-testing-quality/03-write-integration-tests.md",
    "phase": "phase-3-testing-quality",
    "task_number": 3
  },
  {
    "title": "Set Up Application Insights",
    "body": "# Task: Set Up Application Insights\n\n## Phase\nPhase 3: Testing and Quality (Week 2)\n\n## Description\nConfigure Azure Application Insights for comprehensive monitoring and telemetry.\n\n## Objectives\n- Create Application Insights resource\n- Configure instrumentation\n- Add custom telemetry\n- Set up dashboards and alerts\n- Test monitoring\n\n## Dependencies\n- Phase 3: Task 03 - Write Integration Tests\n\n## Tasks\n1. Create Application Insights resource in Azure\n2. Add Microsoft.ApplicationInsights.AspNetCore package\n3. Configure Application Insights in Program.cs\n4. Add instrumentation key to configuration\n5. Add custom telemetry for business events\n6. Configure telemetry processors\n7. Set up dashboards in Azure portal\n8. Configure alerts (exceptions, response time, availability)\n9. Test telemetry collection\n10. Document monitoring setup\n\n## Estimated Effort\n1-2 days\n\n## Acceptance Criteria\n- Application Insights is configured\n- Telemetry is being collected\n- Dashboards show metrics\n- Alerts are configured\n- Documentation complete\n",
    "labels": [
      "phase-3",
      "setup",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-3-testing-quality/04-setup-app-insights.md",
    "phase": "phase-3-testing-quality",
    "task_number": 4
  },
  {
    "title": "Implement Structured Logging with Serilog",
    "body": "# Task: Implement Structured Logging with Serilog\n\n## Phase\nPhase 3: Testing and Quality (Week 2)\n\n## Description\nImplement structured logging using Serilog with Application Insights integration.\n\n## Objectives\n- Add Serilog packages\n- Configure structured logging\n- Add log enrichers\n- Configure Application Insights sink\n- Update logging throughout application\n\n## Dependencies\n- Phase 3: Task 04 - Set Up Application Insights\n\n## Tasks\n1. Add Serilog packages (Serilog.AspNetCore, Serilog.Sinks.ApplicationInsights)\n2. Configure Serilog in Program.cs\n3. Add log enrichers (request, user, environment)\n4. Configure log levels per namespace\n5. Update controllers to use ILogger<T>\n6. Add structured logging to services\n7. Log exceptions with context\n8. Test logging in Application Insights\n9. Remove Debug.WriteLine statements\n10. Document logging standards\n\n## Estimated Effort\n1-2 days\n\n## Acceptance Criteria\n- Serilog is configured\n- Logs appear in Application Insights\n- Structured logging is used throughout\n- Log levels are appropriate\n- Documentation complete\n",
    "labels": [
      "phase-3",
      "migration",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-3-testing-quality/05-implement-logging.md",
    "phase": "phase-3-testing-quality",
    "task_number": 5
  },
  {
    "title": "Add Health Checks and Security Hardening",
    "body": "# Task: Add Health Checks and Security Hardening\n\n## Phase\nPhase 3: Testing and Quality (Week 2)\n\n## Description\nImplement health checks, rate limiting, CSRF protection, and other security enhancements.\n\n## Objectives\n- Add health check endpoints\n- Implement rate limiting\n- Add CSRF protection\n- Add security headers\n- Perform security scan\n\n## Dependencies\n- Phase 3: Task 05 - Implement Structured Logging with Serilog\n\n## Tasks\n1. Add health checks for database, Service Bus, Blob Storage\n2. Expose health check endpoint (/health)\n3. Add AspNetCoreRateLimit package\n4. Configure rate limiting middleware\n5. Enable anti-forgery tokens in forms\n6. Add security headers middleware (HSTS, CSP, etc.)\n7. Configure CORS appropriately\n8. Run security scan (OWASP ZAP or similar)\n9. Fix identified vulnerabilities\n10. Document security measures\n\n## Estimated Effort\n2-3 days\n\n## Acceptance Criteria\n- Health checks are functional\n- Rate limiting works\n- CSRF protection enabled\n- Security headers configured\n- Security scan passed\n- Documentation complete\n",
    "labels": [
      "phase-3",
      "migration",
      "high",
      "2-3-days"
    ],
    "file_path": "tasks/phase-3-testing-quality/06-health-security.md",
    "phase": "phase-3-testing-quality",
    "task_number": 6
  },
  {
    "title": "Performance Testing and Optimization",
    "body": "# Task: Performance Testing and Optimization\n\n## Phase\nPhase 3: Testing and Quality (Week 2)\n\n## Description\nPerform performance testing, identify bottlenecks, and optimize application performance.\n\n## Objectives\n- Run load tests\n- Identify bottlenecks\n- Optimize queries\n- Improve response times\n- Document performance benchmarks\n\n## Dependencies\n- Phase 3: Task 06 - Add Health Checks and Security Hardening\n\n## Tasks\n1. Set up load testing tool (Apache JMeter, k6, or Azure Load Testing)\n2. Create load test scenarios\n3. Run baseline performance tests\n4. Identify slow queries using Application Insights\n5. Optimize N+1 queries with .Include()\n6. Add AsNoTracking() to read-only queries\n7. Consider adding caching (optional)\n8. Re-run performance tests\n9. Document performance improvements\n10. Establish performance benchmarks\n\n## Estimated Effort\n2-3 days\n\n## Acceptance Criteria\n- Load tests completed\n- Bottlenecks identified and resolved\n- Queries optimized\n- Performance benchmarks documented\n- Response times acceptable\n",
    "labels": [
      "phase-3",
      "testing",
      "high",
      "2-3-days"
    ],
    "file_path": "tasks/phase-3-testing-quality/07-performance-testing.md",
    "phase": "phase-3-testing-quality",
    "task_number": 7
  },
  {
    "title": "Create Dockerfile and Test Container Locally",
    "body": "# Task: Create Dockerfile and Test Container Locally\n\n## Phase\nPhase 4: Deployment and Cutover (Day 1-2)\n\n## Description\nCreate Dockerfile for the application and test container build and execution locally.\n\n## Objectives\n- Create optimized Dockerfile\n- Build container image\n- Test container locally\n- Optimize image size\n- Document container build\n\n## Dependencies\n- Phase 3: Task 07 - Performance Testing and Optimization\n\n## Tasks\n1. Create Dockerfile with multi-stage build\n2. Configure base images (.NET 9 SDK and runtime)\n3. Copy application files\n4. Set up entry point\n5. Build container image\n6. Run container locally with Docker Desktop\n7. Test application in container\n8. Optimize image size (remove unnecessary files)\n9. Create .dockerignore file\n10. Document Docker build process\n11. Test with different configurations\n\n## Estimated Effort\n1 day\n\n## Acceptance Criteria\n- Dockerfile created\n- Container builds successfully\n- Application runs in container\n- Can access application on localhost\n- Image size is optimized\n- Documentation complete\n",
    "labels": [
      "phase-4",
      "testing",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-4-deployment/01-create-dockerfile.md",
    "phase": "phase-4-deployment",
    "task_number": 1
  },
  {
    "title": "Push Container to Azure Container Registry",
    "body": "# Task: Push Container to Azure Container Registry\n\n## Phase\nPhase 4: Deployment and Cutover (Day 1-2)\n\n## Description\nCreate Azure Container Registry and push the container image for deployment.\n\n## Objectives\n- Create Azure Container Registry\n- Tag container image\n- Push image to ACR\n- Configure access\n- Test image pull\n\n## Dependencies\n- Phase 4: Task 01 - Create Dockerfile and Test Container Locally\n\n## Tasks\n1. Create Azure Container Registry (Basic tier for dev)\n2. Enable admin access for testing\n3. Log in to ACR using Docker CLI\n4. Tag container image\n5. Push image to ACR\n6. Verify image in Azure portal\n7. Test pulling image from ACR\n8. Configure service principal for CI/CD\n9. Document ACR configuration\n\n## Estimated Effort\n0.5 day\n\n## Acceptance Criteria\n- ACR is created\n- Image pushed successfully\n- Can pull image from ACR\n- CI/CD credentials configured\n- Documentation complete\n",
    "labels": [
      "phase-4",
      "deployment",
      "high",
      "1-week"
    ],
    "file_path": "tasks/phase-4-deployment/02-push-to-acr.md",
    "phase": "phase-4-deployment",
    "task_number": 2
  },
  {
    "title": "Create Azure Container Apps Environment and Deploy",
    "body": "# Task: Create Azure Container Apps Environment and Deploy\n\n## Phase\nPhase 4: Deployment and Cutover (Day 3-4)\n\n## Description\nCreate Container Apps environment, configure the application, and deploy the first version.\n\n## Objectives\n- Create Container Apps environment\n- Configure container app\n- Set up environment variables\n- Configure scaling rules\n- Deploy application\n- Test deployment\n\n## Dependencies\n- Phase 4: Task 02 - Push Container to Azure Container Registry\n\n## Tasks\n1. Create Container Apps environment\n2. Create container app\n3. Configure container image from ACR\n4. Set up environment variables (connection strings, settings)\n5. Configure managed identity for Key Vault access\n6. Configure ingress (HTTPS, external)\n7. Configure scaling rules (HTTP, CPU-based)\n8. Configure health checks\n9. Deploy application\n10. Test application in Azure\n11. Configure custom domain (optional)\n12. Test all functionality\n13. Document deployment configuration\n\n## Estimated Effort\n1-2 days\n\n## Acceptance Criteria\n- Container Apps environment created\n- Application deployed successfully\n- Application is accessible via URL\n- All functionality works\n- Scaling rules configured\n- Health checks functional\n- Documentation complete\n",
    "labels": [
      "phase-4",
      "deployment",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-4-deployment/03-deploy-container-apps.md",
    "phase": "phase-4-deployment",
    "task_number": 3
  },
  {
    "title": "Complete CI/CD Pipeline and Automate Deployment",
    "body": "# Task: Complete CI/CD Pipeline and Automate Deployment\n\n## Phase\nPhase 4: Deployment and Cutover (Day 3-4)\n\n## Description\nComplete the CI/CD pipeline with automated build, test, and deployment to Azure Container Apps.\n\n## Objectives\n- Complete GitHub Actions workflows\n- Automate container build\n- Automate deployment to dev\n- Add manual approval for production\n- Test complete pipeline\n\n## Dependencies\n- Phase 4: Task 03 - Create Azure Container Apps Environment and Deploy\n\n## Tasks\n1. Update .github/workflows/build.yml with full build steps\n2. Create .github/workflows/deploy.yml with deployment logic\n3. Configure GitHub secrets (Azure credentials, ACR credentials)\n4. Add container build and push steps\n5. Add deployment to Container Apps step\n6. Configure environment-specific deployments\n7. Add manual approval gate for production\n8. Test complete pipeline end-to-end\n9. Document CI/CD process\n10. Create rollback procedure\n\n## Estimated Effort\n1 day\n\n## Acceptance Criteria\n- Build workflow builds and tests code\n- Deploy workflow builds container and deploys\n- Can deploy to dev automatically\n- Production deployment requires approval\n- All workflows run successfully\n- Documentation complete\n",
    "labels": [
      "phase-4",
      "deployment",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-4-deployment/04-complete-cicd.md",
    "phase": "phase-4-deployment",
    "task_number": 4
  },
  {
    "title": "Production Deployment and Smoke Tests",
    "body": "# Task: Production Deployment and Smoke Tests\n\n## Phase\nPhase 4: Deployment and Cutover (Day 5)\n\n## Description\nDeploy application to production environment and perform comprehensive smoke tests.\n\n## Objectives\n- Deploy to production\n- Run smoke tests\n- Verify all functionality\n- Monitor for issues\n- Document any problems\n\n## Dependencies\n- Phase 4: Task 04 - Complete CI/CD Pipeline and Automate Deployment\n\n## Tasks\n1. Review pre-deployment checklist\n2. Back up production database\n3. Deploy to production via CI/CD\n4. Run smoke tests:\n   - Test authentication\n   - Test CRUD operations\n   - Test file uploads\n   - Test notifications\n   - Test all major workflows\n5. Monitor Application Insights for errors\n6. Monitor Azure resource health\n7. Verify performance is acceptable\n8. Check logs for any issues\n9. Document deployment\n10. Notify stakeholders of successful deployment\n11. Create post-deployment report\n\n## Estimated Effort\n1 day\n\n## Acceptance Criteria\n- Application deployed to production\n- All smoke tests pass\n- No critical errors in logs\n- Performance is acceptable\n- Monitoring shows healthy status\n- Documentation complete\n- Stakeholders notified\n",
    "labels": [
      "phase-4",
      "testing",
      "high",
      "1-2-days"
    ],
    "file_path": "tasks/phase-4-deployment/05-production-deployment.md",
    "phase": "phase-4-deployment",
    "task_number": 5
  },
  {
    "title": "Monitor Production and Address Issues",
    "body": "# Task: Monitor Production and Address Issues\n\n## Phase\nPost-Migration (Week 12-13)\n\n## Description\nMonitor production environment, address any deployment issues, and tune performance based on real traffic.\n\n## Objectives\n- Monitor production metrics\n- Address any issues\n- Tune performance\n- Train users\n- Update documentation\n\n## Dependencies\n- Phase 4: Task 05 - Production Deployment and Smoke Tests\n\n## Tasks\n1. Monitor Application Insights daily\n2. Review error logs and exceptions\n3. Monitor Azure resource utilization\n4. Address any bugs or issues\n5. Tune database performance\n6. Optimize slow queries\n7. Adjust scaling rules if needed\n8. Conduct user training sessions\n9. Update user documentation\n10. Gather user feedback\n11. Create post-migration report\n\n## Estimated Effort\n1-2 weeks\n\n## Acceptance Criteria\n- No critical issues in production\n- Performance is acceptable\n- Users are trained\n- Documentation is updated\n- Feedback collected\n- Post-migration report created\n",
    "labels": [
      "post-migration",
      "enhancement",
      "medium",
      "2-weeks"
    ],
    "file_path": "tasks/post-migration/01-monitor-and-tune.md",
    "phase": "post-migration",
    "task_number": 1
  },
  {
    "title": "Implement Caching Strategy",
    "body": "# Task: Implement Caching Strategy\n\n## Phase\nPost-Migration (Month 2-3)\n\n## Description\nImplement caching strategy using Azure Cache for Redis to improve performance.\n\n## Objectives\n- Create Azure Cache for Redis\n- Implement caching in application\n- Cache frequently accessed data\n- Configure cache invalidation\n- Measure performance improvements\n\n## Dependencies\n- Post-Migration: Task 01 - Monitor Production and Address Issues\n\n## Tasks\n1. Create Azure Cache for Redis (Basic tier)\n2. Add Microsoft.Extensions.Caching.StackExchangeRedis package\n3. Configure Redis cache in Program.cs\n4. Implement distributed caching for:\n   - Course listings\n   - Department data\n   - Frequently accessed lookups\n5. Implement cache invalidation on updates\n6. Test caching functionality\n7. Measure performance improvements\n8. Document caching strategy\n\n## Estimated Effort\n2-3 days\n\n## Acceptance Criteria\n- Redis cache deployed\n- Caching implemented\n- Cache invalidation works\n- Performance improved\n- Documentation complete\n",
    "labels": [
      "post-migration",
      "enhancement",
      "medium",
      "2-3-days"
    ],
    "file_path": "tasks/post-migration/02-implement-caching.md",
    "phase": "post-migration",
    "task_number": 2
  },
  {
    "title": "Implement Real-Time Notifications with SignalR",
    "body": "# Task: Implement Real-Time Notifications with SignalR\n\n## Phase\nPost-Migration (Month 2-3)\n\n## Description\nAdd real-time notification delivery using SignalR, replacing the polling mechanism.\n\n## Objectives\n- Add SignalR to application\n- Create notification hub\n- Update UI for real-time updates\n- Test real-time delivery\n- Remove polling mechanism\n\n## Dependencies\n- Post-Migration: Task 02 - Implement Caching Strategy\n\n## Tasks\n1. Add Microsoft.AspNetCore.SignalR package\n2. Create NotificationHub\n3. Configure SignalR in Program.cs\n4. Update NotificationService to broadcast via SignalR\n5. Update JavaScript client to use SignalR\n6. Remove polling mechanism\n7. Test real-time notifications\n8. Handle reconnection scenarios\n9. Document SignalR implementation\n\n## Estimated Effort\n2-3 days\n\n## Acceptance Criteria\n- SignalR configured\n- Notifications delivered in real-time\n- UI updates without polling\n- Reconnection works\n- Documentation complete\n",
    "labels": [
      "post-migration",
      "enhancement",
      "medium",
      "2-3-days"
    ],
    "file_path": "tasks/post-migration/03-implement-signalr.md",
    "phase": "post-migration",
    "task_number": 3
  },
  {
    "title": "Set Up Disaster Recovery Plan",
    "body": "# Task: Set Up Disaster Recovery Plan\n\n## Phase\nPost-Migration (Month 2-3)\n\n## Description\nImplement comprehensive disaster recovery plan with backups, geo-redundancy, and recovery procedures.\n\n## Objectives\n- Configure automated backups\n- Set up geo-redundancy\n- Document recovery procedures\n- Test recovery process\n- Create runbooks\n\n## Dependencies\n- Post-Migration: Task 03 - Implement Real-Time Notifications with SignalR\n\n## Tasks\n1. Configure Azure SQL Database backup retention\n2. Test point-in-time restore\n3. Configure geo-replication for production database\n4. Set up blob storage geo-redundancy\n5. Document RTO and RPO requirements\n6. Create disaster recovery runbook\n7. Test failover procedures\n8. Schedule regular DR drills\n9. Document lessons learned\n10. Update documentation\n\n## Estimated Effort\n3-5 days\n\n## Acceptance Criteria\n- Backups configured and tested\n- Geo-redundancy enabled\n- Recovery procedures documented\n- Failover tested successfully\n- DR runbook created\n- Team trained on DR procedures\n",
    "labels": [
      "post-migration",
      "setup",
      "medium",
      "1-week"
    ],
    "file_path": "tasks/post-migration/04-disaster-recovery.md",
    "phase": "post-migration",
    "task_number": 4
  }
]